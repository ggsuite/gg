[{"role":"system","content":[{"type":"text","text":"Folgende Tools stehen zur Verfügung: delete_file, add_file, change_file. \nNutze immer ausschließlich ein oder mehrere Male einen Tool-Call um die Nutzeranfrage zu erfüllen. \nKommentiere Code stets auf Englisch.\nÜbernehme Dateinamen exakt wie angegeben.\nDu kannst auch mehre Dateien gleichzeitig verändern, löschen oder hinzufügen. \nFühre dafür mehrere Tool calls aus.\nAls file_content gibst du den vollständigen Dateiinhalt aus und keine Diffs.\nModifiziere den Code um den / die Fehler zu beheben.\nFalls zusätzliche Instruktionen gegeben werden, bevorzuge diese.\nDu programmierst nach folgenden Code Guidelines:\n# Code Guidelines\r\n\r\n## Code Structure and Modularity\r\n\r\n- Break down large functions into smaller, focused functions.\r\n- Use classes to group related functions and data.\r\n- Use named parameters if a function has more than two parameters or for optional parameters.\r\n- Avoid deep nesting; consider refactoring if there are more than 2-3 levels.\r\n- Separate UI code from business logic and data manipulation.\r\n- Keep the codebase organized with clear file and folder structures.\r\n\r\n## Error Handling and Robustness\r\n\r\n- Implement error handling especially around I/O operations and external integrations.\r\n- Validate user input and external data rigorously.\r\n- Use assertions to document and enforce assumptions in the code.\r\n- Consider using the `Either` or `Result` pattern for functions that can return an error.\r\n\r\n## Commenting\r\n\r\n### File Headers\r\n\r\nBegin each Dart file with the following header:\r\n\r\n```dart\r\n// @license\r\n// Copyright (c) 2019 - 2025 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n```\r\n\r\n### Classes\r\n- Use triple slash (`///`) documentation comments directly above class declarations.\r\n- Provide a brief summary of what the class represents.\r\n- Optionally include further details and example usage.\r\n\r\n### Methods\r\n- Document methods using triple slash comments (`///`) immediately before the method declaration.\r\n- Include descriptions for parameters, return values, and potential exceptions.\r\n\r\n### Attributes (Fields)\r\n- Comment on public fields with triple slash comments (`///`).\r\n- Use inline comments or document getters/setters for private fields when necessary.\r\n\r\n## JSON Serialization using the json_serializable Package\r\n\r\nYou should use the `json_serializable` package to simplify JSON serialization.\r\n\r\nSteps:\r\n1. Add the `json_serializable` and `build_runner` packages to your dev dependencies in `pubspec.yaml`.\r\n2. Annotate your class with `@JsonSerializable()`.\r\n3. Include a part file (e.g., `part 'person.g.dart';`).\r\n\r\nExample:\r\n\r\n```dart\r\nimport 'package:json_annotation/json_annotation.dart';\r\n\r\npart 'person.g.dart';\r\n\r\n@JsonSerializable()\r\nclass Person {\r\n  /// Name of the person\r\n  final String name;\r\n  \r\n  /// Age of the person\r\n  final int age;\r\n  \r\n  /// Whether the person is verified\r\n  /// Defaults to false if not specified\r\n  @JsonKey(defaultValue: false)\r\n  final bool isVerified;\r\n  \r\n  Person({\r\n    required this.name, \r\n    required this.age, \r\n    this.isVerified = false\r\n  });\r\n  \r\n  /// Creates a Person instance from a JSON map.\r\n  factory Person.fromJson(Map<String, dynamic> json) => _$PersonFromJson(json);\r\n  \r\n  /// Converts a Person instance to a JSON map.\r\n  Map<String, dynamic> toJson() => _$PersonToJson(this);\r\n}\r\n```\r\n\r\n## Widget Structure\r\n\r\n- Use Small, Focused Widgets: Break down large UI components into smaller, reusable widgets.\r\n- Prefer Composition Over Inheritance: Compose new widgets from existing ones rather than building large class hierarchies.\r\n- Nest Wisely: Avoid deeply nested widget trees by extracting smaller widget segments into separate methods or classes.\r\n- Create own widgets for repeated UI elements\r\n- Use `const` constructors for stateless widgets to improve performance.\r\n- Use `Key` when necessary to maintain widget state.\r\n\r\nExample:\r\n\r\nBad:\r\n```dart\r\nclass MyApp extends StatelessWidget {\r\n  const MyApp({Key? key}) : super(key: key);\r\n}\r\n```\r\n\r\nGood:\r\n```dart\r\nclass MyApp extends StatelessWidget {\r\n  const MyApp({super.key});\r\n  // ...\r\n}\r\n```\r\n\r\n- Create separate files for each widget if they are complex or reusable.\r\n- Create own widgets for items in ListView, GridView, etc.\r\n\r\nExample:\r\n\r\nInstead of one huge widget:\r\n```dart\r\nclass ProfileScreen extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      children: [\r\n        // A lot of UI elements for profile\r\n      ],\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nYou should break it down into smaller widgets:\r\n```dart\r\nclass ProfileScreen extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      children: [\r\n        ProfileHeader(),\r\n        ProfileDetails(),\r\n        ProfileActions(),\r\n      ],\r\n    );\r\n  }\r\n}\r\n\r\nclass ProfileHeader extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    // ...\r\n  }\r\n}\r\n\r\n// ... other widget classes\r\n```\r\n\r\n## State Management\r\n\r\n- Always use Riverpod for state management.\r\n\r\n## Performance\r\n\r\n- Use `const` constructors if possible\r\n- Use `ListView.builder` instead of `ListView` for long lists\r\n- Use stateless widgets whenever possible\r\n- Use FutureBuilder and StreamBuilder for asynchronous data\r\n- Use dispose method to clean up resources in StatefulWidgets\r\n\r\n### Network\r\n\r\n- Use http client with cache:\r\n\r\nExample:\r\n\r\n```dart\r\nimport 'package:http/http.dart' as http;\r\nimport 'package:http_cache/http_cache.dart';\r\n\r\nfinal httpClient = http.Client();\r\nfinal client = CachingHttpClient(httpClient);\r\n\r\nFuture<void> fetchData() async {\r\n  final response = await client.get(Uri.parse('<https://api.example.com/data>'));\r\n  // ...\r\n}\r\n```\r\n\r\n- local caching with SharedPreferences\r\n\r\nExample:\r\n\r\n```dart\r\nimport 'package:shared_preferences/shared_preferences.dart';\r\n\r\nFuture<void> cacheData(String key, String value) async {\r\n  final prefs = await SharedPreferences.getInstance();\r\n  await prefs.setString(key, value);\r\n}\r\n\r\nFuture<String?> getCachedData(String key) async {\r\n  final prefs = await SharedPreferences.getInstance();\r\n  return prefs.getString(key);\r\n}\r\n```\r\n\r\n- for parallel requests use `Future.wait`\r\n\r\n## Best Practices\r\n\r\n- Keep documentation clear, concise, and up-to-date.\r\n- Ensure consistency in commenting style across the codebase.\r\n- Regularly update serialization logic and documentation as the code evolves.\r\n- Avoid magic numbers; use named constants instead.\r\n- Use enums for a fixed set of related constants.\r\n- Follow the DRY (Don't Repeat Yourself) principle to improve maintainability.\r\n"}]},{"role":"user","content":[{"type":"text","text":"Project structure:\n.aicode\n.dart_tool\n.git\n.gitattributes\n.github\n.gitignore\n.idea\n.markdownlint.json\n.vscode\nanalysis_options.yaml\nbin\nbin\\gg.dart\nCHANGELOG.md\ncheck.yaml\ncoverage\nexample\ninstall.bat\ninstall.dart\nlib\nlib\\gg.dart\nlib\\src\nlib\\src\\commands\nlib\\src\\commands\\can\nlib\\src\\commands\\can\\can_commit.dart\nlib\\src\\commands\\can\\can_merge.dart\nlib\\src\\commands\\can\\can_publish.dart\nlib\\src\\commands\\can\\can_push.dart\nlib\\src\\commands\\can\\can_upgrade.dart\nlib\\src\\commands\\can.dart\nlib\\src\\commands\\check\nlib\\src\\commands\\check\\analyze.dart\nlib\\src\\commands\\check\\format.dart\nlib\\src\\commands\\check\\pana.dart\nlib\\src\\commands\\check.dart\nlib\\src\\commands\\did\nlib\\src\\commands\\did\\did_commit.dart\nlib\\src\\commands\\did\\did_publish.dart\nlib\\src\\commands\\did\\did_push.dart\nlib\\src\\commands\\did\\did_upgrade.dart\nlib\\src\\commands\\did.dart\nlib\\src\\commands\\do\nlib\\src\\commands\\do\\do_commit.dart\nlib\\src\\commands\\do\\do_maintain.dart\nlib\\src\\commands\\do\\do_merge.dart\nlib\\src\\commands\\do\\do_publish.dart\nlib\\src\\commands\\do\\do_push.dart\nlib\\src\\commands\\do\\do_upgrade.dart\nlib\\src\\commands\\do.dart\nlib\\src\\commands\\info.dart\nlib\\src\\gg.dart\nlib\\src\\tools\nlib\\src\\tools\\carriage_return.dart\nlib\\src\\tools\\checks.dart\nlib\\src\\tools\\command_cluster.dart\nlib\\src\\tools\\did_command.dart\nlib\\src\\tools\\gg_state.dart\nLICENSE\npubspec.lock\npubspec.yaml\npubspec.yaml' '\nREADME.md\ntemp.json\ntest\ntest\\bin\ntest\\bin\\gg_test.dart\ntest\\commands\ntest\\commands\\can\ntest\\commands\\can\\can_commit_test.dart\ntest\\commands\\can\\can_merge_test.dart\ntest\\commands\\can\\can_publish_test.dart\ntest\\commands\\can\\can_push_test.dart\ntest\\commands\\can\\can_upgrade_test.dart\ntest\\commands\\can_test.dart\ntest\\commands\\check\ntest\\commands\\check\\analyze_test.dart\ntest\\commands\\check\\format_test.dart\ntest\\commands\\check\\pana_test.dart\ntest\\commands\\check_test.dart\ntest\\commands\\did\ntest\\commands\\did\\did_commit_test.dart\ntest\\commands\\did\\did_publish_test.dart\ntest\\commands\\did\\did_push_test.dart\ntest\\commands\\did\\did_upgrade_test.dart\ntest\\commands\\did_test.dart\ntest\\commands\\do\ntest\\commands\\do\\do_commit_test.dart\ntest\\commands\\do\\do_maintain_test.dart\ntest\\commands\\do\\do_merge_test.dart\ntest\\commands\\do\\do_publish_test.dart\ntest\\commands\\do\\do_push_test.dart\ntest\\commands\\do\\do_upgrade_test.dart\ntest\\commands\\do_test.dart\ntest\\commands\\info_test.dart\ntest\\data\ntest\\data\\pana_not_success_report.json\ntest\\data\\pana_success_report.json\ntest\\gg_test.dart\ntest\\tools\ntest\\tools\\carriage_return_test.dart\ntest\\tools\\checks_test.dart\ntest\\tools\\command_cluster_test.dart\ntest\\tools\\did_command_test.dart\ntest\\tools\\gg_state_test.dart\ntest\\vscode\ntest\\vscode\\launch_json_test.dart\n\n\n\nlib\\src\\tools\\gg_state.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_direct_json/gg_direct_json.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:path/path.dart';\r\n\r\n/// Stores and retrieves the state of the check commands\r\nclass GgState {\r\n  /// Constructor\r\n  GgState({\r\n    required this.ggLog,\r\n    LastChangesHash? lastChangesHash,\r\n    IsCommitted? isCommitted,\r\n    IsPushed? isPushed,\r\n    ModifiedFiles? modifiedFiles,\r\n    Commit? commit,\r\n    HeadMessage? headMessage,\r\n    HasRemote? hasRemote,\r\n    CommitCount? commitCount,\r\n  }) : _lastChangesHash = lastChangesHash ?? LastChangesHash(ggLog: ggLog),\r\n       _isPushed = isPushed ?? IsPushed(ggLog: ggLog),\r\n       _modifiedFiles = modifiedFiles ?? ModifiedFiles(ggLog: ggLog),\r\n       _commit = commit ?? Commit(ggLog: ggLog),\r\n       _headMessage = headMessage ?? HeadMessage(ggLog: ggLog),\r\n       _hasRemote = hasRemote ?? HasRemote(ggLog: ggLog),\r\n       _commitCount = commitCount ?? CommitCount(ggLog: ggLog);\r\n\r\n  // ...........................................................................\r\n  /// The logger used for logging\r\n  final GgLog ggLog;\r\n\r\n  // ...........................................................................\r\n  /// The file that might be ignored while reading the hash\r\n  static const ignoreFiles = ['.gg.json', 'CHANGELOG.md'];\r\n\r\n  // ...........................................................................\r\n  /// Returns previously set value\r\n  Future<bool> readSuccess({\r\n    required Directory directory,\r\n    required String key,\r\n    required GgLog ggLog,\r\n  }) async {\r\n    // Get the last changes hash\r\n    final changesHash = await _lastChangesHash.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n      ignoreFiles: ignoreFiles,\r\n    );\r\n\r\n    // If no config file exists, return false\r\n    final fileExists = await File(\r\n      _configFile(directory: directory).path,\r\n    ).exists();\r\n\r\n    if (!fileExists) {\r\n      return false;\r\n    }\r\n\r\n    // Get the hash written to .gg.json\r\n    final hashInCheckJson = await DirectJson.readFile<int>(\r\n      file: _configFile(directory: directory),\r\n      path: _hashPath(key).join('/'),\r\n    );\r\n\r\n    // Compare the two hashes\r\n    // If they are the same, return true.\r\n    // If they are different, return false.\r\n    return changesHash == hashInCheckJson;\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Updates .gg.json and writes the success state for this key.\r\n  Future<void> writeSuccess({\r\n    required Directory directory,\r\n    required String key,\r\n  }) async {\r\n    // Nothing committed so far? Do nothing.\r\n    await _checkCommitsAvailable(directory, ggLog);\r\n\r\n    // If success is already written, return\r\n    final isWritten = await readSuccess(\r\n      directory: directory,\r\n      key: key,\r\n      ggLog: ggLog,\r\n    );\r\n    if (isWritten) {\r\n      return;\r\n    }\r\n\r\n    // Get the hash of the current commit\r\n    final hash = await currentHash(directory: directory, ggLog: ggLog);\r\n\r\n    // Write the hash to .gg.json\r\n    await DirectJson.writeFile(\r\n      file: _configFile(directory: directory),\r\n      path: _hashPath(key).join('/'),\r\n      value: hash,\r\n    );\r\n\r\n    // Ammend changes to .gg.json\r\n    await _commitOrAmmendStateChanges(directory);\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Returns the current hash of the last changes\r\n  Future<int> currentHash({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n  }) async {\r\n    return await _lastChangesHash.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n      ignoreFiles: ignoreFiles,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Replaces the hash in .gg.json with the current hash\r\n  Future<void> updateHash({\r\n    required int hash,\r\n    required Directory directory,\r\n  }) async {\r\n    final current = await currentHash(directory: directory, ggLog: ggLog);\r\n    if (current == hash) {\r\n      return;\r\n    }\r\n\r\n    final ggJsonFile = _configFile(directory: directory);\r\n\r\n    if (!await ggJsonFile.exists()) {\r\n      return;\r\n    }\r\n\r\n    final ggJSonFileContent = (await ggJsonFile.readAsString()).replaceAll(\r\n      '$hash',\r\n      '$current',\r\n    );\r\n    await ggJsonFile.writeAsString(ggJSonFileContent);\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Resets the success state\r\n  Future<void> reset({required Directory directory}) async {\r\n    await _configFile(directory: directory).writeAsString('{}');\r\n  }\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  final LastChangesHash _lastChangesHash;\r\n\r\n  final IsPushed _isPushed;\r\n  final ModifiedFiles _modifiedFiles;\r\n  final Commit _commit;\r\n  final HeadMessage _headMessage;\r\n  final HasRemote _hasRemote;\r\n  final CommitCount _commitCount;\r\n\r\n  // ...........................................................................\r\n  List<String> _hashPath(String name) => [name, 'success', 'hash'];\r\n\r\n  // ...........................................................................\r\n  File _configFile({required Directory directory}) {\r\n    final filePath = join(directory.path, '.gg.json');\r\n    final file = File(filePath);\r\n    return file;\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<void> _commitOrAmmendStateChanges(Directory directory) async {\r\n    // Check if only .gg.json is currently changed\r\n    final modifiedFiles = await _modifiedFiles.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // If nothing changed, return\r\n    if (modifiedFiles.isEmpty) {\r\n      return;\r\n    }\r\n\r\n    final onlyGgJsonChanged =\r\n        modifiedFiles.length == 1 && modifiedFiles.first == '.gg.json';\r\n\r\n    // Remember if everything is committed and pushed\r\n    final everythingWasCommitted = onlyGgJsonChanged;\r\n\r\n    // If not everything was committed before, return here.\r\n    //  gg.json will be committed with the next commit.\r\n    if (!everythingWasCommitted) {\r\n      return;\r\n    }\r\n\r\n    // ...................................\r\n    // Otherwise commit or ammend .gg.json\r\n\r\n    // Check if the repository has a remote\r\n    final hasRemote = await _hasRemote.get(directory: directory, ggLog: ggLog);\r\n\r\n    final everythingWasPushed = hasRemote && await _wasPushed(directory);\r\n\r\n    // ...........................\r\n    // To have a clean git history,\r\n    // we will ammend changes to .gg.json to the last commit.\r\n    // - If everything was committed and pushed, create a new commit\r\n    // - If everything was committed but not pushed, ammend to last commit\r\n    final message = everythingWasPushed\r\n        ? 'Add: .gg.json check results'\r\n        : await _headMessage.get(\r\n            directory: directory,\r\n            ggLog: ggLog,\r\n            throwIfNotEverythingIsCommitted: false,\r\n          );\r\n\r\n    await _commit.commit(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n      doStage: true,\r\n      message: message,\r\n      ammend: !everythingWasPushed,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<bool> _wasPushed(Directory directory) async {\r\n    return await _isPushed.get(\r\n      directory: directory,\r\n      ggLog: (_) {},\r\n      ignoreUnCommittedChanges: true,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<void> _checkCommitsAvailable(Directory directory, GgLog ggLog) async {\r\n    final commitCount = await _commitCount.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n    if (commitCount == 0) {\r\n      throw Exception('There must be at least one commit in the repository.');\r\n    }\r\n  }\r\n}\r\n\r\n/// Mock for [GgState]\r\nclass MockGgState extends MockDirCommand<void> implements GgState {}\r\n\n\nlib\\src\\tools\\did_command.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/tools/gg_state.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\nimport 'package:meta/meta.dart';\r\n\r\n/// Base class for all did commands\r\nclass DidCommand extends DirCommand<bool> {\r\n  /// Constructor\r\n  DidCommand({\r\n    required super.name,\r\n    required super.description,\r\n    required this.shortDescription,\r\n    required this.suggestion,\r\n    required super.ggLog,\r\n    required this.stateKey,\r\n    GgState? state,\r\n  }) : state = state ?? GgState(ggLog: ggLog);\r\n\r\n  // ...........................................................................\r\n  @override\r\n  @mustCallSuper\r\n  Future<bool> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n  }) async {\r\n    final messages = <String>[];\r\n\r\n    final result =\r\n        await GgStatusPrinter<bool>(\r\n          message: shortDescription,\r\n          ggLog: ggLog,\r\n        ).logTask(\r\n          task: () => get(ggLog: messages.add, directory: directory),\r\n          success: (success) => success,\r\n        );\r\n\r\n    if (!result) {\r\n      final printedMessages = <String>[\r\n        colorizeSuggestion(suggestion),\r\n        brightBlack(messages.join('\\n')),\r\n      ];\r\n\r\n      throw Exception(printedMessages.join('\\n'));\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Returns previously set value\r\n  @override\r\n  Future<bool> get({required Directory directory, required GgLog ggLog}) async {\r\n    final success = await state.readSuccess(\r\n      directory: directory,\r\n      key: stateKey,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    return success;\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Returns previously set value\r\n  Future<void> set({required Directory directory}) async {\r\n    await state.writeSuccess(directory: directory, key: stateKey);\r\n  }\r\n\r\n  /// The question to be answered by the did command\r\n  final String shortDescription;\r\n\r\n  /// The suggestions shown when the state was not successful\r\n  final String suggestion;\r\n\r\n  /// The state key used to retrieve the success state\r\n  final String stateKey;\r\n\r\n  /// Saves and restores the success state\r\n  final GgState state;\r\n\r\n  /// Formats the suggestion string by applying the blue color to the text\r\n  /// between » and «\r\n  static String colorizeSuggestion(String suggestion) {\r\n    const startSymbol = '»';\r\n    const endSymbol = '«';\r\n\r\n    StringBuffer buffer = StringBuffer();\r\n    int startIndex = 0;\r\n    int endIndex = 0;\r\n\r\n    // Loop through the input string to find and process all occurrences\r\n    while (true) {\r\n      startIndex = suggestion.indexOf(startSymbol, endIndex);\r\n      if (startIndex == -1) break; // No more start symbols found, exit loop\r\n\r\n      // Add text up to the startSymbol to the buffer\r\n      buffer.write(darkGray(suggestion.substring(endIndex, startIndex)));\r\n\r\n      endIndex = suggestion.indexOf(endSymbol, startIndex);\r\n      if (endIndex == -1) break; // No matching end symbol found, exit loop\r\n\r\n      // Extract the text between the symbols, apply the format function,\r\n      // and add to the buffer\r\n      String textToFormat = suggestion.substring(startIndex + 1, endIndex);\r\n      buffer.write(blue(textToFormat));\r\n\r\n      endIndex += 1; // Move past the endSymbol for the next iteration\r\n    }\r\n\r\n    // Add any remaining text after the last processed section\r\n    buffer.write(darkGray(suggestion.substring(endIndex)));\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n}\r\n\r\n/// Mock for [DidCommand]\r\nclass MockDidCommand extends MockDirCommand<bool> implements DidCommand {}\r\n\n\nlib\\src\\tools\\command_cluster.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/tools/gg_state.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\n\r\n/// A cluster of commands that is run in sequence\r\nclass CommandCluster extends DirCommand<void> {\r\n  /// Constructor\r\n  CommandCluster({\r\n    required super.ggLog,\r\n    required this.commands,\r\n    required super.name,\r\n    required super.description,\r\n    required this.stateKey,\r\n    required this.shortDescription,\r\n    GgState? state,\r\n  }) : _state = state ?? GgState(ggLog: ggLog) {\r\n    _addArgs();\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// The short description printed at the beginning of each command\r\n  final String shortDescription;\r\n\r\n  /// The state key used to save the state of the command cluster\r\n  final String stateKey;\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? force,\r\n    bool? saveState,\r\n  }) => get(\r\n    directory: directory,\r\n    ggLog: ggLog,\r\n    force: force,\r\n    saveState: saveState,\r\n  );\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? force,\r\n    bool? saveState,\r\n  }) async {\r\n    ggLog(yellow(shortDescription));\r\n\r\n    // If we have no commands, let's do nothing.\r\n    if (commands.isEmpty) {\r\n      return;\r\n    }\r\n\r\n    // Was successful before? Do nothing.\r\n    if (!await _actionIsNeeded(directory, ggLog, force)) {\r\n      _printAlreadyDoneSuccess(ggLog);\r\n      return;\r\n    }\r\n\r\n    // Execute commands.\r\n    try {\r\n      for (final command in commands) {\r\n        await command.exec(directory: directory, ggLog: ggLog);\r\n      }\r\n\r\n      // Save success\r\n      saveState ??= argResults?['save-state'] as bool? ?? true;\r\n      if (saveState) {\r\n        await _state.writeSuccess(directory: directory, key: stateKey);\r\n      }\r\n    } catch (e) {\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  /// The commands to run\r\n  final List<DirCommand<void>> commands;\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  final GgState _state;\r\n\r\n  // ...........................................................................\r\n  void _addArgs() {\r\n    argParser.addFlag(\r\n      'force',\r\n      abbr: 'f',\r\n      negatable: false,\r\n      help: 'Executes the commands also if they were successful before.',\r\n      defaultsTo: false,\r\n    );\r\n\r\n    argParser.addFlag(\r\n      'save-state',\r\n      abbr: 's',\r\n      negatable: true,\r\n      help: 'Saves success state for later reuse.',\r\n      defaultsTo: true,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<bool> _wasSuccessfulBefore(Directory directory, GgLog ggLog) async {\r\n    return await _state.readSuccess(\r\n      directory: directory,\r\n      key: stateKey,\r\n      ggLog: ggLog,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<bool> _actionIsNeeded(\r\n    Directory directory,\r\n    GgLog ggLog,\r\n    bool? force,\r\n  ) async {\r\n    force = force ?? argResults?['force'] as bool? ?? false;\r\n    final needsAction =\r\n        force || !(await _wasSuccessfulBefore(directory, ggLog));\r\n    return needsAction;\r\n  }\r\n\r\n  // ...........................................................................\r\n  void _printAlreadyDoneSuccess(GgLog ggLog) {\r\n    GgStatusPrinter<void>(\r\n      message: 'Everything is fine.',\r\n      ggLog: ggLog,\r\n      useCarriageReturn: false,\r\n    ).logStatus(GgStatusPrinterStatus.success);\r\n  }\r\n}\r\n\n\nlib\\src\\tools\\checks.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_test/gg_test.dart';\r\nimport 'package:gg_version/gg_version.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\n\r\n// .............................................................................\r\n/// Dependencies for the check command\r\nclass Checks {\r\n  /// Constructor\r\n  Checks({\r\n    required this.ggLog,\r\n    Analyze? analyze,\r\n    Format? format,\r\n    Tests? tests,\r\n    Pana? pana,\r\n    IsPushed? isPushed,\r\n    IsCommitted? isCommitted,\r\n    IsVersioned? isVersioned,\r\n    IsPublished? isPublished,\r\n    IsUpgraded? isUpgraded,\r\n  }) : analyze = analyze ?? Analyze(ggLog: ggLog),\r\n       format = format ?? Format(ggLog: ggLog),\r\n       tests = tests ?? Tests(ggLog: ggLog),\r\n       pana = pana ?? Pana(ggLog: ggLog),\r\n       isPushed = isPushed ?? IsPushed(ggLog: ggLog),\r\n       isCommitted = isCommitted ?? IsCommitted(ggLog: ggLog),\r\n       isVersioned = isVersioned ?? IsVersioned(ggLog: ggLog),\r\n       isPublished = isPublished ?? IsPublished(ggLog: ggLog),\r\n       isUpgraded = isUpgraded ?? IsUpgraded(ggLog: ggLog) {\r\n    _initAll();\r\n  }\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// The analyze command\r\n  final Analyze analyze;\r\n\r\n  /// The format command\r\n  final Format format;\r\n\r\n  /// The coverage command\r\n  final Tests tests;\r\n\r\n  /// The pana command\r\n  final Pana pana;\r\n\r\n  /// The isPushed command\r\n  final IsPushed isPushed;\r\n\r\n  /// The isCommitted command\r\n  final IsCommitted isCommitted;\r\n\r\n  /// The isVersioned command\r\n  final IsVersioned isVersioned;\r\n\r\n  /// The isPublished command\r\n  final IsPublished isPublished;\r\n\r\n  /// The isUpgraded command\r\n  final IsUpgraded isUpgraded;\r\n\r\n  /// Returns a list of all commands\r\n  Iterable<DirCommand<void>> get all => _all;\r\n\r\n  // ...........................................................................\r\n  late List<DirCommand<void>> _all;\r\n\r\n  void _initAll() {\r\n    _all = [\r\n      analyze,\r\n      format,\r\n      tests,\r\n      pana,\r\n      isPushed,\r\n      isCommitted,\r\n      isVersioned,\r\n      isPublished,\r\n      isUpgraded,\r\n    ];\r\n  }\r\n}\r\n\n\nlib\\gg.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nlibrary;\r\n\r\nexport 'src/gg.dart';\r\n\r\n// Checks\r\nexport 'src/commands/check.dart';\r\nexport 'src/commands/check/analyze.dart';\r\nexport 'src/commands/check/format.dart';\r\nexport 'src/commands/check/pana.dart';\r\n\r\n// Can\r\nexport 'src/commands/can.dart';\r\nexport 'src/commands/can/can_push.dart';\r\nexport 'src/commands/can/can_commit.dart';\r\nexport 'src/commands/can/can_publish.dart';\r\nexport 'src/commands/can/can_upgrade.dart';\r\nexport 'src/commands/can/can_merge.dart';\r\n\r\n// Do\r\nexport 'src/commands/do.dart';\r\nexport 'src/commands/do/do_push.dart';\r\nexport 'src/commands/do/do_commit.dart';\r\nexport 'src/commands/do/do_publish.dart';\r\nexport 'src/commands/do/do_upgrade.dart';\r\nexport 'src/commands/do/do_maintain.dart';\r\nexport 'src/commands/do/do_merge.dart';\r\n\r\n// Did\r\nexport 'src/commands/did.dart';\r\nexport 'src/commands/did/did_push.dart';\r\nexport 'src/commands/did/did_commit.dart';\r\nexport 'src/commands/did/did_publish.dart';\r\nexport 'src/commands/did/did_upgrade.dart';\r\n\r\n// Tools\r\nexport 'src/tools/carriage_return.dart';\r\nexport 'src/tools/command_cluster.dart';\r\nexport 'src/tools/checks.dart';\r\nexport 'src/tools/gg_state.dart';\r\n\r\n// Info\r\nexport 'src/commands/info.dart';\r\n\n\nlib\\src\\tools\\carriage_return.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\n/// The carriage return\r\nString get carriageReturn => '\\x1b[1A\\x1b[2K';\r\n\n\nlib\\src\\gg.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\n\r\n/// The command line interface for gg\r\nclass Gg extends Command<dynamic> {\r\n  /// Constructor\r\n  Gg({\r\n    required this.ggLog,\r\n    GgProcessWrapper processWrapper = const GgProcessWrapper(),\r\n  }) {\r\n    addSubcommand(Check(ggLog: ggLog));\r\n    addSubcommand(Can(ggLog: ggLog));\r\n    addSubcommand(Did(ggLog: ggLog));\r\n    addSubcommand(Do(ggLog: ggLog));\r\n    addSubcommand(Info(ggLog: ggLog));\r\n  }\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  // ...........................................................................\r\n  @override\r\n  final name = 'gg';\r\n  @override\r\n  final description = 'The convenient dart & flutter developer commandline.';\r\n}\r\n\n\nlib\\src\\commands\\info.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\n\r\n// .............................................................................\r\n/// Commands to inform about the source code\r\nclass Info extends Command<void> {\r\n  /// Constructor\r\n  Info({required this.ggLog}) {\r\n    _initSubCommands();\r\n  }\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// Then name of the command\r\n  @override\r\n  final name = 'info';\r\n\r\n  /// The description of the command\r\n  @override\r\n  final description = 'Commands to inform about the source code.';\r\n\r\n  // ...........................................................................\r\n  void _initSubCommands() {\r\n    addSubcommand(ModifiedFiles(ggLog: ggLog));\r\n    addSubcommand(LastChangesHash(ggLog: ggLog));\r\n  }\r\n}\r\n\n\nlib\\src\\commands\\do.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\n\r\n// .............................................................................\r\n/// Various checks for the source code\r\nclass Do extends Command<void> {\r\n  /// Constructor\r\n  Do({required this.ggLog, DepsOfDo? deps}) {\r\n    deps ??= DepsOfDo(ggLog: ggLog);\r\n    _initSubCommands(deps);\r\n  }\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// Then name of the command\r\n  @override\r\n  final name = 'do';\r\n\r\n  /// The description of the command\r\n  @override\r\n  final description = 'Provide actions or commit, push, publish, merge.';\r\n\r\n  // ...........................................................................\r\n  void _initSubCommands(DepsOfDo deps) {\r\n    addSubcommand(deps.doCommit);\r\n    addSubcommand(deps.doPush);\r\n    addSubcommand(deps.doPublish);\r\n    addSubcommand(deps.doUpgrade);\r\n    addSubcommand(DoMaintain(ggLog: ggLog));\r\n    addSubcommand(deps.doMerge);\r\n  }\r\n}\r\n\r\n// .............................................................................\r\n/// Dependencies for the check command\r\nclass DepsOfDo {\r\n  /// Constructor\r\n  DepsOfDo({\r\n    required this.ggLog,\r\n    DoCommit? doCommit,\r\n    DoPush? doPush,\r\n    DoPublish? doPublish,\r\n    DoUpgrade? doUpgrade,\r\n    DoMerge? doMerge,\r\n  }) : doCommit = doCommit ?? DoCommit(ggLog: ggLog),\r\n       doPush = doPush ?? DoPush(ggLog: ggLog),\r\n       doPublish = doPublish ?? DoPublish(ggLog: ggLog),\r\n       doUpgrade = doUpgrade ?? DoUpgrade(ggLog: ggLog),\r\n       doMerge = doMerge ?? DoMerge(ggLog: ggLog);\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// The can commit command\r\n  final DoCommit doCommit;\r\n\r\n  /// The can commit command\r\n  final DoPush doPush;\r\n\r\n  /// The do publish command\r\n  final DoPublish doPublish;\r\n\r\n  /// The do upgrade command\r\n  final DoUpgrade doUpgrade;\r\n\r\n  /// The do merge command\r\n  final DoMerge doMerge;\r\n}\r\n\n\nlib\\src\\commands\\do\\do_upgrade.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\nimport 'package:matcher/expect.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\n\r\n/// Upgrades all dependencies\r\nclass DoUpgrade extends DirCommand<void> {\r\n  /// Constructor\r\n  DoUpgrade({\r\n    required super.ggLog,\r\n    super.name = 'upgrade',\r\n    super.description = 'Upgrades all dependencies',\r\n    GgState? state,\r\n    DidUpgrade? didUpgrade,\r\n    CanUpgrade? canUpgrade,\r\n    GgProcessWrapper processWrapper = const GgProcessWrapper(),\r\n    CanCommit? canCommit,\r\n  }) : _state = state ?? GgState(ggLog: ggLog),\r\n       _processWrapper = processWrapper,\r\n       _didUpgrade = didUpgrade ?? DidUpgrade(ggLog: ggLog),\r\n       _canUpgrade = canUpgrade ?? CanUpgrade(ggLog: ggLog),\r\n       _canCommit = canCommit ?? CanCommit(ggLog: ggLog) {\r\n    _addParam();\r\n  }\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? majorVersions,\r\n  }) => get(directory: directory, ggLog: ggLog, majorVersions: majorVersions);\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? majorVersions,\r\n  }) async {\r\n    majorVersions ??= _majorVersionsFromArgs;\r\n\r\n    // Use this log method to supress logs.\r\n    void noLog(_) {} // coverage:ignore-line\r\n\r\n    // Does directory exist?\r\n    await check(directory: directory);\r\n\r\n    // Is already upgraded?\r\n    final isDone = await _didUpgrade.get(\r\n      directory: directory,\r\n      ggLog: noLog,\r\n      majorVersions: majorVersions,\r\n    );\r\n\r\n    if (isDone) {\r\n      ggLog(yellow('Everything is already up to date.'));\r\n      return;\r\n    }\r\n\r\n    // Can upgrade?\r\n    await _canUpgrade.exec(directory: directory, ggLog: ggLog);\r\n\r\n    // Remember the state before the upgrade\r\n    final hashBefore = await _state.currentHash(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // Perform the upgrade\r\n    await _runDartPubUpgrade(\r\n      directory: directory,\r\n      majorVersions: majorVersions,\r\n    );\r\n\r\n    // Check if everything is still running after the update\r\n    try {\r\n      await _canCommit.exec(\r\n        directory: directory,\r\n        ggLog: ggLog,\r\n        force: true, // Checks need to be done, even if if nothing has changed\r\n      );\r\n    }\r\n    // When not everything is running, reset success sate\r\n    catch (e) {\r\n      await _state.reset(directory: directory);\r\n      throw Exception(\r\n        red(\r\n          'After the update tests are not running anymore. '\r\n          'Please run ${blue('»gg can commit«')} and try again.',\r\n        ),\r\n      );\r\n    }\r\n\r\n    // If nothing has changed, return\r\n    final hashAfter = await _state.currentHash(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    if (hashBefore == hashAfter) {\r\n      ggLog(yellow('No changes after the upgrade.'));\r\n      return;\r\n    }\r\n  }\r\n\r\n  /// The key used to save the state of the command\r\n  final String stateKey = 'doUpgrade';\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  // ...........................................................................\r\n  final GgState _state;\r\n  final GgProcessWrapper _processWrapper;\r\n  final DidUpgrade _didUpgrade;\r\n  final CanUpgrade _canUpgrade;\r\n  final CanCommit _canCommit;\r\n\r\n  // ...........................................................................\r\n  void _addParam() {\r\n    argParser.addFlag(\r\n      'major-versions',\r\n      abbr: 'm',\r\n      help:\r\n          'Upgrades packages to their latest resolvable versions, '\r\n          'and updates pubspec.yaml.',\r\n      defaultsTo: false,\r\n      negatable: false,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Runs »dart pub upgrade«\r\n  Future<void> _runDartPubUpgrade({\r\n    required Directory directory,\r\n    required bool majorVersions,\r\n  }) async {\r\n    final args = ['pub', 'upgrade', if (majorVersions) '--major-versions'];\r\n\r\n    await GgStatusPrinter<bool>(\r\n      message: 'Run »dart ${args.join(' ')}«',\r\n      ggLog: ggLog,\r\n    ).logTask(\r\n      task: () async {\r\n        final result = await _processWrapper.run(\r\n          'dart',\r\n          args,\r\n          workingDirectory: directory.path,\r\n        );\r\n\r\n        if (result.exitCode != 0) {\r\n          throw Exception('»dart pub upgrade« failed: ${result.stderr}');\r\n        }\r\n\r\n        return true;\r\n      },\r\n      success: (success) => success,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  bool get _majorVersionsFromArgs {\r\n    final majorVersions = argResults?['major-versions'] as bool? ?? false;\r\n    return majorVersions;\r\n  }\r\n}\r\n\r\n/// Mock for [DoUpgrade].\r\nclass MockDoUpgrade extends MockDirCommand<void> implements DoUpgrade {\r\n  // ...........................................................................\r\n  /// Makes [exec] successful or not\r\n  @override\r\n  void mockExec({\r\n    void result,\r\n    GgLog? ggLog,\r\n    Directory? directory,\r\n    bool? majorVersions,\r\n    bool doThrow = false,\r\n    String? message,\r\n  }) {\r\n    when(\r\n      () => exec(\r\n        directory: any(\r\n          named: 'directory',\r\n          that: predicate<Directory>(\r\n            (d) => directory == null || d.path == directory.path,\r\n          ),\r\n        ),\r\n        ggLog: ggLog ?? any(named: 'ggLog'),\r\n        majorVersions: majorVersions,\r\n      ),\r\n    ).thenAnswer((invocation) async {\r\n      return defaultReaction(\r\n        doThrow: doThrow,\r\n        message: message,\r\n        invocation: invocation,\r\n        result: null,\r\n      );\r\n    });\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Makes [get] successful or not\r\n  @override\r\n  void mockGet({\r\n    void result,\r\n    GgLog? ggLog,\r\n    Directory? directory,\r\n    bool? majorVersions,\r\n    bool doThrow = false,\r\n    String? message,\r\n  }) {\r\n    when(\r\n      () => get(\r\n        directory: any(\r\n          named: 'directory',\r\n          that: predicate<Directory>(\r\n            (d) => directory == null || d.path == directory.path,\r\n          ),\r\n        ),\r\n        ggLog: ggLog ?? any(named: 'ggLog'),\r\n        majorVersions: majorVersions,\r\n      ),\r\n    ).thenAnswer((invocation) async {\r\n      return defaultReaction(\r\n        doThrow: doThrow,\r\n        message: message,\r\n        invocation: invocation,\r\n        result: null,\r\n      );\r\n    });\r\n  }\r\n}\r\n\n\nlib\\src\\commands\\do\\do_push.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/commands/can/can_push.dart';\r\nimport 'package:gg/src/tools/gg_state.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\n\r\n/// Pushes the current state.\r\nclass DoPush extends DirCommand<void> {\r\n  /// Constructor\r\n  DoPush({\r\n    required super.ggLog,\r\n    super.name = 'push',\r\n    super.description = 'Pushes the current state.',\r\n    IsPushed? isPushed,\r\n    CanPush? canPush,\r\n    GgProcessWrapper processWrapper = const GgProcessWrapper(),\r\n    GgState? state,\r\n    UpstreamBranch? upstreamBranch,\r\n    LocalBranch? localBranch,\r\n  }) : _processWrapper = processWrapper,\r\n       _isPushedViaGit = isPushed ?? IsPushed(ggLog: ggLog),\r\n       _canPush = canPush ?? CanPush(ggLog: ggLog),\r\n       _upstreamBranch = upstreamBranch ?? UpstreamBranch(ggLog: ggLog),\r\n       _localBranch = localBranch ?? LocalBranch(ggLog: ggLog),\r\n       state = state ?? GgState(ggLog: ggLog) {\r\n    _addParam();\r\n  }\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? force,\r\n  }) => get(directory: directory, ggLog: ggLog, force: force);\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? force,\r\n  }) async {\r\n    // Does directory exist?\r\n    await check(directory: directory);\r\n\r\n    // Is everything pushed?\r\n    final isPushedViaGit = await _isPushedViaGit.get(\r\n      directory: directory,\r\n      ggLog: (_) {}, // coverage:ignore-line\r\n    );\r\n\r\n    // Is didPush already set?\r\n    if (isPushedViaGit) {\r\n      final isDone = await state.readSuccess(\r\n        directory: directory,\r\n        key: stateKey,\r\n        ggLog: ggLog,\r\n      );\r\n\r\n      if (isDone) {\r\n        ggLog(yellow('Already checked and pushed.'));\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Is everything fine?\r\n    await _canPush.exec(directory: directory, ggLog: ggLog);\r\n\r\n    // Write success before pushing\r\n    await state.writeSuccess(directory: directory, key: stateKey);\r\n\r\n    // Did .gg.json change? Is a new push needed?\r\n    final isPushedViaGitAfterWritingSuccess = await _isPushedViaGit.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // Execute the commit\r\n    if (!isPushedViaGitAfterWritingSuccess) {\r\n      force ??= _forceFromArgs();\r\n      await gitPush(directory: directory, force: force);\r\n      ggLog(yellow('Checks successful. Pushed successful.'));\r\n    }\r\n  }\r\n\r\n  /// The state used to save the state of the command\r\n  final GgState state;\r\n\r\n  /// The key used to save the state of the command\r\n  final String stateKey = 'doPush';\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  // ...........................................................................\r\n  final GgProcessWrapper _processWrapper;\r\n  final IsPushed _isPushedViaGit;\r\n  final CanPush _canPush;\r\n\r\n  final UpstreamBranch _upstreamBranch;\r\n  final LocalBranch _localBranch;\r\n\r\n  // ...........................................................................\r\n  void _addParam() {\r\n    argParser.addFlag(\r\n      'force',\r\n      abbr: 'f',\r\n      help: 'Do a force push.',\r\n      defaultsTo: false,\r\n      negatable: true,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Pushes the current state to the remote.\r\n  Future<void> gitPush({\r\n    required Directory directory,\r\n    required bool force,\r\n    bool pushTags = false,\r\n  }) async {\r\n    final didPush = await _pushNewBranch(directory);\r\n    if (!didPush) {\r\n      await _pushExistingBranch(force, pushTags, directory);\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<void> _pushExistingBranch(\r\n    bool force,\r\n    bool pushTags,\r\n    Directory directory,\r\n  ) async {\r\n    final result = await _processWrapper.run('git', [\r\n      'push',\r\n      if (force) '-f',\r\n      if (pushTags) '--tags', // coverage:ignore-line\r\n    ], workingDirectory: directory.path);\r\n\r\n    if (result.exitCode != 0) {\r\n      throw Exception('git push failed: ${result.stderr}');\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<bool> _pushNewBranch(Directory directory) async {\r\n    final upstreamBranch = await _upstreamBranch.get(\r\n      ggLog: ggLog,\r\n      directory: directory,\r\n    );\r\n\r\n    if (upstreamBranch.isNotEmpty) {\r\n      return false;\r\n    }\r\n\r\n    final localBranch = await _localBranch.get(\r\n      ggLog: ggLog,\r\n      directory: directory,\r\n    );\r\n\r\n    final result = await _processWrapper.run('git', [\r\n      'push',\r\n      '--set-upstream',\r\n      'origin',\r\n      localBranch,\r\n    ], workingDirectory: directory.path);\r\n\r\n    if (result.exitCode != 0) {\r\n      throw Exception(\r\n        'git push --set-upstream origin $localBranch failed: ${result.stderr}',\r\n      );\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // ...........................................................................\r\n  bool _forceFromArgs() {\r\n    final force = argResults?['force'] as bool? ?? false;\r\n    return force;\r\n  }\r\n}\r\n\r\n/// Mock for [DoPush].\r\nclass MockDoPush extends MockDirCommand<void> implements DoPush {}\r\n\n\nlib\\src\\commands\\can\\can_push.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\n\r\n/// Are the last changes ready for »git push«?\r\nclass CanPush extends CommandCluster {\r\n  /// Constructor\r\n  CanPush({\r\n    required super.ggLog,\r\n    Checks? checkCommands,\r\n    super.name = 'push',\r\n    super.shortDescription = 'Can push?',\r\n    super.description = 'Are the last changes ready for »git push«?',\r\n    super.stateKey = 'canPush',\r\n  }) : super(commands: _checks(checkCommands, ggLog));\r\n\r\n  // ...........................................................................\r\n  static List<DirCommand<void>> _checks(Checks? checks, GgLog ggLog) {\r\n    checks ??= Checks(ggLog: ggLog);\r\n    return [checks.isCommitted];\r\n  }\r\n}\r\n\r\n// .............................................................................\r\n/// A mocktail mock\r\nclass MockCanPush extends MockDirCommand<void> implements CanPush {}\r\n\n\nlib\\src\\commands\\do\\do_publish.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_changelog/gg_changelog.dart' as changelog;\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\nimport 'package:gg_version/gg_version.dart';\r\nimport 'package:path/path.dart';\r\n\r\n/// Publishes the current directory.\r\nclass DoPublish extends DirCommand<void> {\r\n  /// Constructor\r\n  DoPublish({\r\n    required super.ggLog,\r\n    super.name = 'publish',\r\n    super.description = 'Publishes the current directory.',\r\n    CanPublish? canPublish,\r\n    Publish? publish,\r\n    GgState? state,\r\n    AddVersionTag? addVersionTag,\r\n    Commit? commit,\r\n    DoPush? doPush,\r\n    PrepareNextVersion? prepareNextVersion,\r\n    FromPubspec? fromPubspec,\r\n    IsPublished? isPublished,\r\n    changelog.Release? release,\r\n    PublishTo? publishTo,\r\n  }) : _canPublish = canPublish ?? CanPublish(ggLog: ggLog),\r\n       _publishToPubDev = publish ?? Publish(ggLog: ggLog),\r\n       _state = state ?? GgState(ggLog: ggLog),\r\n       _addVersionTag = addVersionTag ?? AddVersionTag(ggLog: ggLog),\r\n       _commit = commit ?? Commit(ggLog: ggLog),\r\n       _doPush = doPush ?? DoPush(ggLog: ggLog),\r\n       _prepareNextVersion =\r\n           prepareNextVersion ?? PrepareNextVersion(ggLog: ggLog),\r\n       _fromPubspec = fromPubspec ?? FromPubspec(ggLog: ggLog),\r\n       _releaseChangelog = release ?? changelog.Release(ggLog: ggLog),\r\n       _isPublished = isPublished ?? IsPublished(ggLog: ggLog),\r\n       _publishTo = publishTo ?? PublishTo(ggLog: ggLog) {\r\n    _addArgs();\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// The key used to save the state of the command\r\n  final String stateKey = 'doPublish';\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? askBeforePublishing,\r\n  }) => get(\r\n    directory: directory,\r\n    ggLog: ggLog,\r\n    askBeforePublishing: askBeforePublishing,\r\n  );\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? askBeforePublishing,\r\n  }) async {\r\n    // Does directory exist?\r\n    await check(directory: directory);\r\n    void noLog(_) {} // coverage:ignore-line\r\n\r\n    // Did already publish?\r\n    final isDone = await _state.readSuccess(\r\n      directory: directory,\r\n      key: stateKey,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    if (isDone) {\r\n      ggLog(yellow('Current state is already published.'));\r\n      return;\r\n    }\r\n\r\n    // Should ask before publishing?\r\n    askBeforePublishing = await _shouldAskBeforePublishing(\r\n      directory,\r\n      ggLog,\r\n      askBeforePublishing,\r\n    );\r\n\r\n    // Can publish?\r\n    await _canPublish.exec(directory: directory, ggLog: ggLog);\r\n\r\n    // Publish change log using cider\r\n    await _prepareChangelog(directory: directory, ggLog: noLog);\r\n\r\n    // Publish on pub.dev\r\n    final publishToPubDev = await _shouldPublishToPubDev(directory, ggLog);\r\n\r\n    if (publishToPubDev) {\r\n      await _publishToPubDev.exec(\r\n        directory: directory,\r\n        ggLog: ggLog,\r\n        askBeforePublishing: askBeforePublishing,\r\n      );\r\n    }\r\n\r\n    // Save state\r\n    await _state.writeSuccess(directory: directory, key: stateKey);\r\n\r\n    // Push commits to remote\r\n    await _doPush.exec(\r\n      directory: directory,\r\n      ggLog: (_) {}, // coverage:ignore-line\r\n      force: false,\r\n    );\r\n\r\n    // Add git version tag\r\n    await _addVersionTag.exec(\r\n      directory: directory,\r\n      ggLog: (msg) => ggLog('✅ $msg'),\r\n    );\r\n\r\n    // Push tags to remote\r\n    await _doPush.gitPush(directory: directory, force: false, pushTags: true);\r\n\r\n    // Prepare next version\r\n    await _addNextVersion(directory, ggLog);\r\n  }\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  // ...........................................................................\r\n  final Publish _publishToPubDev;\r\n  final CanPublish _canPublish;\r\n  final GgState _state;\r\n  final AddVersionTag _addVersionTag;\r\n  final DoPush _doPush;\r\n  final Commit _commit;\r\n  final PrepareNextVersion _prepareNextVersion;\r\n  final FromPubspec _fromPubspec;\r\n  final changelog.Release _releaseChangelog;\r\n  final IsPublished _isPublished;\r\n  final PublishTo _publishTo;\r\n\r\n  // ...........................................................................\r\n  Future<void> _prepareChangelog({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n  }) async {\r\n    // Remember current hash\r\n    final hashBefore = await _state.currentHash(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // Release the changelog\r\n    await _releaseChangelog.exec(directory: directory, ggLog: ggLog);\r\n\r\n    // Update state\r\n    await _state.updateHash(hash: hashBefore, directory: directory);\r\n\r\n    // Commit changes to change log\r\n    await _commit.commit(\r\n      ggLog: ggLog,\r\n      directory: directory,\r\n      doStage: true,\r\n      message: 'Prepare changelog for release',\r\n      ammendWhenNotPushed: true,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<void> _addNextVersion(Directory directory, GgLog ggLog) async {\r\n    // Define increment\r\n    const increment = VersionIncrement.patch;\r\n\r\n    // Remember current hash\r\n    final hashBefore = await _state.currentHash(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // Get version in pubspec.yaml\r\n    final publishedVersion = await _fromPubspec.fromDirectory(\r\n      directory: directory,\r\n    );\r\n\r\n    // Prepare the next version\r\n    await _prepareNextVersion.exec(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n      increment: increment,\r\n      publishedVersion: publishedVersion,\r\n    );\r\n\r\n    // Update state\r\n    await _state.updateHash(hash: hashBefore, directory: directory);\r\n\r\n    // Get new version\r\n    final newVersion = await _fromPubspec.fromDirectory(directory: directory);\r\n\r\n    // Commit changes to change log\r\n    await _commit.commit(\r\n      ggLog: ggLog,\r\n      directory: directory,\r\n      doStage: true,\r\n      message: 'Prepare development of version $newVersion',\r\n      ammendWhenNotPushed: false,\r\n    );\r\n\r\n    // Push commits to remote\r\n    await _doPush.gitPush(directory: directory, force: false);\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<bool> _shouldAskBeforePublishing(\r\n    Directory directory,\r\n    GgLog ggLog,\r\n    bool? askBeforePublishing,\r\n  ) async {\r\n    askBeforePublishing ??= _askBeforePublishingFromParam;\r\n\r\n    // Where should the package be published?\r\n    final target = await _publishTo.fromDirectory(directory);\r\n    final publishToNone = target == 'none';\r\n    if (publishToNone) {\r\n      return false;\r\n    }\r\n\r\n    // Check package was published before\r\n    final wasPublishedBefore = await _isPublished.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // When --ask-for-confirmation is true, always ask\r\n    if (askBeforePublishing) {\r\n      return true;\r\n    }\r\n\r\n    // When --ask-for-confirmation is false,\r\n    // don't ask, when package is already published\r\n    if (wasPublishedBefore) {\r\n      return false;\r\n    }\r\n\r\n    /// If the package was never published before,\r\n    /// and askBeforePublishing is false,\r\n    /// throw an exception.\r\n    /// Before publishing the package the first time,\r\n    /// always ask.\r\n    throw Exception(\r\n      'The package was never published to pub.dev before. '\r\n      'Please call »gg do push« with »--ask-before-publishing« '\r\n      'when publishing the first time.',\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<bool> _shouldPublishToPubDev(Directory directory, GgLog ggLog) async {\r\n    final pubspecFile = File(join(directory.path, 'pubspec.yaml'));\r\n    final pubspec = await pubspecFile.readAsString();\r\n    return !pubspec.contains(RegExp(r'publish_to:'));\r\n  }\r\n\r\n  // ...........................................................................\r\n  bool get _askBeforePublishingFromParam =>\r\n      argResults?['ask-before-publishing'] as bool? ?? true;\r\n\r\n  // ...........................................................................\r\n  void _addArgs() {\r\n    argParser.addFlag(\r\n      'ask-before-publishing',\r\n      abbr: 'a',\r\n      help: 'Ask for confirmation before publishing to pub.dev.',\r\n      defaultsTo: true,\r\n      negatable: true,\r\n    );\r\n  }\r\n}\r\n\r\n/// Mock for [DoPublish].\r\nclass MockDoPublish extends MockDirCommand<void> implements DoPublish {}\r\n\n\nlib\\src\\commands\\do\\do_merge.dart:\n// @license\r\n// Copyright (c) 2025 Göran Hegenberg. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\nimport 'package:gg_merge/gg_merge.dart' as gg_merge;\r\n\r\n/// Performs checks and merge/Pull-Request (PR/MR to main) in one step.\r\nclass DoMerge extends DirCommand<void> {\r\n  /// Constructor\r\n  DoMerge({\r\n    required super.ggLog,\r\n    super.name = 'merge',\r\n    super.description = 'Checks and performs merge/Pull-Request to main.',\r\n    CanMerge? canMerge,\r\n    gg_merge.DoMerge? doMerge,\r\n    GgState? state,\r\n  }) : _canMerge = canMerge ?? CanMerge(ggLog: ggLog),\r\n       _doMerge = doMerge ?? gg_merge.DoMerge(ggLog: ggLog),\r\n       _state = state ?? GgState(ggLog: ggLog) {\r\n    _addArgs();\r\n  }\r\n\r\n  final CanMerge _canMerge;\r\n  final gg_merge.DoMerge _doMerge;\r\n  final GgState _state;\r\n\r\n  /// The key used to save the state of the command\r\n  static const String stateKey = 'doMerge';\r\n\r\n  bool get _automergeFromArgs => argResults?['automerge'] as bool? ?? false;\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? automerge,\r\n  }) async {\r\n    await check(directory: directory);\r\n    return get(directory: directory, ggLog: ggLog, automerge: automerge);\r\n  }\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? automerge,\r\n  }) async {\r\n    automerge ??= _automergeFromArgs;\r\n    await GgStatusPrinter<void>(\r\n      ggLog: ggLog,\r\n      message: 'Performing merge.',\r\n    ).logTask(\r\n      task: () async {\r\n        // First, check preconditions using CanMerge\r\n        await _canMerge.exec(directory: directory, ggLog: ggLog);\r\n        // Now, perform/do the merge using gg_merge's DoMerge\r\n        await _doMerge.get(\r\n          directory: directory,\r\n          ggLog: ggLog,\r\n          automerge: automerge,\r\n        );\r\n        // Save success state\r\n        await _state.writeSuccess(directory: directory, key: stateKey);\r\n      },\r\n      success: (_) => true,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  void _addArgs() {\r\n    argParser.addFlag(\r\n      'automerge',\r\n      abbr: 'a',\r\n      help: 'Set PR/MR to automerge after CI.',\r\n      negatable: true,\r\n      defaultsTo: false,\r\n    );\r\n  }\r\n}\r\n\r\n/// Mock for [DoMerge]\r\nclass MockDoMerge extends MockDirCommand<void> implements DoMerge {}\r\n\n\nlib\\src\\commands\\do\\do_maintain.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\n\r\n/// Upgrades all dependencies\r\nclass DoMaintain extends DirCommand<void> {\r\n  /// Constructor\r\n  DoMaintain({\r\n    required super.ggLog,\r\n    super.name = 'maintain',\r\n    super.description = 'Is the package upgraded and published?',\r\n    GgState? state,\r\n    DoUpgrade? doUpgrade,\r\n    DidPublish? didPublish,\r\n  }) : _didPublish = didPublish ?? DidPublish(ggLog: ggLog),\r\n       _doUpgrade = doUpgrade ?? DoUpgrade(ggLog: ggLog) {\r\n    _addParam();\r\n  }\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? majorVersions,\r\n  }) {\r\n    return get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n      majorVersions: majorVersions,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? majorVersions,\r\n  }) async {\r\n    majorVersions ??= _majorVersionsFromArgs;\r\n\r\n    final messages = <String>[];\r\n\r\n    // Run »gg do upgrade«\r\n    await GgStatusPrinter<void>(\r\n      ggLog: ggLog,\r\n      message: 'Upgrading dependencies',\r\n    ).logTask(\r\n      task: () => _doUpgrade.get(\r\n        directory: directory,\r\n        ggLog: messages.add,\r\n        majorVersions: majorVersions,\r\n      ),\r\n      success: (result) => true,\r\n    );\r\n\r\n    // Rung »gg did publish«\r\n    await _didPublish.exec(directory: directory, ggLog: ggLog);\r\n  }\r\n\r\n  /// The key used to save the state of the command\r\n  final String stateKey = 'doMaintain';\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  // ...........................................................................\r\n\r\n  final DoUpgrade _doUpgrade;\r\n  final DidPublish _didPublish;\r\n\r\n  // ...........................................................................\r\n  void _addParam() {\r\n    argParser.addFlag(\r\n      'major-versions',\r\n      abbr: 'm',\r\n      help:\r\n          'Upgrades packages to their latest resolvable versions, '\r\n          'and updates pubspec.yaml.',\r\n      defaultsTo: false,\r\n      negatable: false,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  bool get _majorVersionsFromArgs {\r\n    final majorVersions = argResults?['major-versions'] as bool? ?? false;\r\n    return majorVersions;\r\n  }\r\n}\r\n\r\n/// Mock for [DoMaintain].\r\nclass MockDoMaintain extends MockDirCommand<void> implements DoMaintain {}\r\n\n\nlib\\src\\commands\\do\\do_commit.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/commands/can/can_commit.dart';\r\nimport 'package:gg/src/tools/gg_state.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_changelog/gg_changelog.dart' as cl;\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\n\r\ncl.LogType _stringToLogType(String e) {\r\n  e = e.toLowerCase();\r\n\r\n  if (e.startsWith('add')) {\r\n    return cl.LogType.added;\r\n  } else if (e.contains('change')) {\r\n    return cl.LogType.changed;\r\n  } else if (e.contains('deprecate')) {\r\n    return cl.LogType.deprecated;\r\n  } else if (e.contains('fix')) {\r\n    return cl.LogType.fixed;\r\n  } else if (e.contains('remove')) {\r\n    return cl.LogType.removed;\r\n  } else if (e.contains('secure')) {\r\n    return cl.LogType.security;\r\n  }\r\n\r\n  return cl.LogType.changed;\r\n}\r\n\r\n// .............................................................................\r\n/// Does a commit of the current directory.\r\nclass DoCommit extends DirCommand<void> {\r\n  /// Constructor\r\n  DoCommit({\r\n    required super.ggLog,\r\n    super.name = 'commit',\r\n    super.description = 'Commits the current directory.',\r\n    IsCommitted? isCommitted,\r\n    CanCommit? canCommit,\r\n    Commit? commit,\r\n    GgProcessWrapper processWrapper = const GgProcessWrapper(),\r\n    GgState? state,\r\n    cl.Add? addToChangeLog,\r\n  }) : _processWrapper = processWrapper,\r\n       _isGitCommitted = isCommitted ?? IsCommitted(ggLog: ggLog),\r\n       _canCommit = canCommit ?? CanCommit(ggLog: ggLog),\r\n       _commit = commit ?? Commit(ggLog: ggLog),\r\n       state = state ?? GgState(ggLog: ggLog),\r\n       _addToChangeLog = addToChangeLog ?? cl.Add(ggLog: ggLog) {\r\n    _addParam();\r\n  }\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> exec({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    String? message,\r\n    cl.LogType? logType,\r\n    bool? updateChangeLog,\r\n  }) => get(\r\n    directory: directory,\r\n    ggLog: ggLog,\r\n    message: message,\r\n    logType: logType,\r\n    updateChangeLog: updateChangeLog,\r\n  );\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    String? message,\r\n    cl.LogType? logType,\r\n    bool? updateChangeLog,\r\n  }) async {\r\n    // Does directory exist?\r\n    await check(directory: directory);\r\n\r\n    // Is everything committed?\r\n    final isCommittedViaGit = await _isGitCommitted.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // Is didCommit already set?\r\n    if (isCommittedViaGit) {\r\n      final isDone = await state.readSuccess(\r\n        directory: directory,\r\n        key: stateKey,\r\n        ggLog: ggLog,\r\n      );\r\n\r\n      if (isDone) {\r\n        ggLog(yellow('Already checked and committed.'));\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Check needed options\r\n    try {\r\n      message ??= _getMessageFromArgs();\r\n      logType ??= _getLogTypeFromMessage(message);\r\n    } catch (e) {\r\n      // type and message are only needed when there are uncommitted changes.\r\n      if (!isCommittedViaGit) {\r\n        rethrow;\r\n      } else {\r\n        logType = cl.LogType.changed;\r\n        message = '';\r\n      }\r\n    }\r\n\r\n    final repoUrl = await _repositoryUrl(directory);\r\n\r\n    // Is everything fine?\r\n    await _canCommit.exec(directory: directory, ggLog: ggLog);\r\n\r\n    // Update changelog when a message is given\r\n    updateChangeLog ??= argResults?['log'] as bool? ?? true;\r\n    if (updateChangeLog) {\r\n      await _writeMessageIntoChangeLog(\r\n        directory: directory,\r\n        message: message,\r\n        logType: logType,\r\n        repoUrl: repoUrl,\r\n        commit: isCommittedViaGit,\r\n      );\r\n    }\r\n\r\n    // Execute the commit\r\n    if (!isCommittedViaGit) {\r\n      await gitAddAndCommit(\r\n        directory: directory,\r\n        message: message,\r\n        logType: logType,\r\n      );\r\n      ggLog(yellow('Checks successful. Commit successful.'));\r\n    } else {\r\n      ggLog(yellow('Checks successful. Nothing to commit.'));\r\n    }\r\n\r\n    // Save the state\r\n    await state.writeSuccess(directory: directory, key: stateKey);\r\n  }\r\n\r\n  /// The state used to save the state of the command\r\n  final GgState state;\r\n\r\n  /// The key used to save the state of the command\r\n  final String stateKey = 'doCommit';\r\n\r\n  // ...........................................................................\r\n  /// Adds and commits the current directory.\r\n  Future<void> gitAddAndCommit({\r\n    required Directory directory,\r\n    required String message,\r\n    required cl.LogType logType,\r\n  }) async {\r\n    await _gitAdd(directory, message);\r\n    await _gitCommit(directory: directory, message: message, logType: logType);\r\n  }\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  // ...........................................................................\r\n  final GgProcessWrapper _processWrapper;\r\n  final IsCommitted _isGitCommitted;\r\n  final CanCommit _canCommit;\r\n  final Commit _commit;\r\n  final cl.Add _addToChangeLog;\r\n\r\n  // ...........................................................................\r\n  void _addParam() {\r\n    argParser.addFlag(\r\n      'log',\r\n      abbr: 'l',\r\n      help: 'Do not add message to CHANGELOG.md.',\r\n      negatable: true,\r\n      defaultsTo: true,\r\n    );\r\n\r\n    argParser.addOption(\r\n      'message',\r\n      abbr: 'm',\r\n      help: 'The commit message and log entry.',\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<void> _gitAdd(Directory directory, String message) async {\r\n    final result = await _processWrapper.run('git', [\r\n      'add',\r\n      '.',\r\n    ], workingDirectory: directory.path);\r\n\r\n    if (result.exitCode != 0) {\r\n      throw Exception('git add failed: ${result.stderr}');\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Executes the git commit command.\r\n  Future<void> _gitCommit({\r\n    required Directory directory,\r\n    required String message,\r\n    required cl.LogType logType,\r\n  }) async {\r\n    final result = await _processWrapper.run('git', [\r\n      'commit',\r\n      '-m',\r\n      message,\r\n    ], workingDirectory: directory.path);\r\n\r\n    if (result.exitCode != 0) {\r\n      throw Exception('git commit failed: ${result.stderr}');\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// The help text printed when message is missing.\r\n  String get helpOnMissingMessage {\r\n    final part0 = red('Run again with message.\\n');\r\n    final part1 = blue('gg do commit ${yellow('-m<your message>')}');\r\n    return '$part0$part1';\r\n  }\r\n\r\n  // ...........................................................................\r\n  cl.LogType _getLogTypeFromMessage(String message) {\r\n    try {\r\n      return _stringToLogType(message);\r\n    } catch (e) {\r\n      return cl.LogType.changed;\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  String _getMessageFromArgs() {\r\n    final String message = (argResults?['message'] ?? '') as String;\r\n    if (message.isEmpty) {\r\n      throw Exception(helpOnMissingMessage);\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<String> _repositoryUrl(Directory directory) async {\r\n    final pubspec = await File('${directory.path}/pubspec.yaml').readAsString();\r\n    RegExp regExp = RegExp(r'^\\s*repository:\\s*(.+)$', multiLine: true);\r\n    Match? match = regExp.firstMatch(pubspec);\r\n    String? repositoryUrl = match?.group(1)?.replaceAll(RegExp(r'/$'), '');\r\n    if (repositoryUrl == null) {\r\n      throw Exception('No »repository:« found in pubspec.yaml');\r\n    }\r\n    return repositoryUrl;\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<bool> _writeMessageIntoChangeLog({\r\n    required Directory directory,\r\n    required String message,\r\n    required cl.LogType logType,\r\n    required String repoUrl,\r\n    required bool commit,\r\n  }) async {\r\n    // Check if message is already in CHANGELOG.md\r\n    final changeLog = await File(\r\n      '${directory.path}/CHANGELOG.md',\r\n    ).readAsString();\r\n\r\n    if (changeLog.contains(message)) {\r\n      return false;\r\n    }\r\n\r\n    // Remember hash before\r\n    final hashBefore = await state.currentHash(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n    );\r\n\r\n    // Use cider to write into CHANGELOG.md\r\n    await _addToChangeLog.exec(\r\n      directory: directory,\r\n      ggLog: (_) {}, // coverage:ignore-line\r\n      message: message,\r\n      logType: logType,\r\n    );\r\n\r\n    // Replace previous hash by new hash in .gg.json\r\n    // Thus »gg can commit|push|publish« will not start from beginning\r\n    await state.updateHash(hash: hashBefore, directory: directory);\r\n\r\n    // If everything was committed before, commit the new changes also\r\n    if (commit) {\r\n      await _commit.commit(\r\n        ggLog: (_) {}, // coverage:ignore-line\r\n        directory: directory,\r\n        doStage: true,\r\n        message: message,\r\n        ammendWhenNotPushed: true,\r\n      );\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\n// .............................................................................\r\n/// Mock for [DoCommit].\r\nclass MockDoCommit extends MockDirCommand<void> implements DoCommit {}\r\n\n\nlib\\src\\commands\\can\\can_commit.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:matcher/expect.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\n\r\n/// Are the last changes ready for »git commit«?\r\nclass CanCommit extends CommandCluster {\r\n  /// Constructor\r\n  CanCommit({\r\n    required super.ggLog,\r\n    Checks? checks,\r\n    super.name = 'commit',\r\n    super.description = 'Are the last changes ready for »git commit«?',\r\n    super.shortDescription = 'Can commit?',\r\n    super.stateKey = 'canCommit',\r\n  }) : super(commands: _checks(checks, ggLog));\r\n\r\n  // ...........................................................................\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? force,\r\n    bool? saveState,\r\n  }) async {\r\n    // Execute commands.\r\n    await super.get(directory: directory, ggLog: ggLog, force: force);\r\n  }\r\n\r\n  // ...........................................................................\r\n  static List<DirCommand<void>> _checks(Checks? checks, GgLog ggLog) {\r\n    checks ??= Checks(ggLog: ggLog);\r\n\r\n    return [checks.analyze, checks.format, checks.tests];\r\n  }\r\n}\r\n\r\n// .............................................................................\r\n/// A mocktail mock\r\nclass MockCanCommit extends MockDirCommand<void> implements CanCommit {\r\n  /// Makes [exec] successful or not\r\n  @override\r\n  void mockExec({\r\n    required void result,\r\n    Directory? directory,\r\n    GgLog? ggLog,\r\n    bool? force,\r\n    bool? saveState,\r\n    bool doThrow = false,\r\n    String? message,\r\n  }) {\r\n    when(\r\n      () => exec(\r\n        directory: any(\r\n          named: 'directory',\r\n          that: predicate<Directory>(\r\n            (d) => directory == null || d.path == directory.path,\r\n          ),\r\n        ),\r\n        ggLog: ggLog ?? any(named: 'ggLog'),\r\n        force: force,\r\n        saveState: saveState,\r\n      ),\r\n    ).thenAnswer((invocation) async {\r\n      return defaultReaction(\r\n        doThrow: doThrow,\r\n        invocation: invocation,\r\n        result: null,\r\n        message: message,\r\n      );\r\n    });\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Mocks the result of the get command\r\n  @override\r\n  void mockGet({\r\n    required void result,\r\n    Directory? directory,\r\n    GgLog? ggLog,\r\n    bool? force,\r\n    bool? saveState,\r\n    bool doThrow = false,\r\n    String? message,\r\n  }) {\r\n    when(\r\n      () => get(\r\n        ggLog: ggLog ?? any(named: 'ggLog'),\r\n        directory: any(\r\n          named: 'directory',\r\n          that: predicate<Directory>(\r\n            (d) => directory == null || d.path == directory.path,\r\n          ),\r\n        ),\r\n        saveState: saveState,\r\n        force: force,\r\n      ),\r\n    ).thenAnswer((invocation) async {\r\n      return defaultReaction(\r\n        doThrow: doThrow,\r\n        invocation: invocation,\r\n        result: null,\r\n        message: message,\r\n      );\r\n    });\r\n  }\r\n}\r\n\n\nlib\\src\\commands\\did.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\n\r\n// .............................................................................\r\n/// Various checks for the source code\r\nclass Did extends Command<void> {\r\n  /// Constructor\r\n  Did({required this.ggLog, DepsOfDid? deps}) {\r\n    deps ??= DepsOfDid(ggLog: ggLog);\r\n    _initSubCommands(deps);\r\n  }\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// Then name of the command\r\n  @override\r\n  final name = 'did';\r\n\r\n  /// The description of the command\r\n  @override\r\n  final description = 'Checks if you did commit, push, publish, ....';\r\n\r\n  // ...........................................................................\r\n  void _initSubCommands(DepsOfDid deps) {\r\n    addSubcommand(deps.didCommit);\r\n    addSubcommand(deps.didPush);\r\n    addSubcommand(deps.didPublish);\r\n    addSubcommand(deps.didUpgrade);\r\n  }\r\n}\r\n\r\n// .............................................................................\r\n/// Dependencies for the check command\r\nclass DepsOfDid {\r\n  /// Constructor\r\n  DepsOfDid({\r\n    required this.ggLog,\r\n    DidCommit? commit,\r\n    DidPush? push,\r\n    DidPublish? publish,\r\n    DidUpgrade? upgrade,\r\n  }) : didCommit = commit ?? DidCommit(ggLog: ggLog),\r\n       didPush = push ?? DidPush(ggLog: ggLog),\r\n       didPublish = publish ?? DidPublish(ggLog: ggLog),\r\n       didUpgrade = upgrade ?? DidUpgrade(ggLog: ggLog);\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// The can commit command\r\n  final DidCommit didCommit;\r\n\r\n  /// The can push command\r\n  final DidPush didPush;\r\n\r\n  /// The can publish command\r\n  final DidPublish didPublish;\r\n\r\n  /// The can publish command\r\n  final DidUpgrade didUpgrade;\r\n}\r\n\n\nlib\\src\\commands\\did\\did_upgrade.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/tools/did_command.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\nimport 'package:matcher/expect.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\n\r\n/// Are the dependencies of the package upgraded?\r\nclass DidUpgrade extends DidCommand {\r\n  /// Constructor\r\n  DidUpgrade({\r\n    required super.ggLog,\r\n    super.name = 'upgrade',\r\n    super.description = 'Are the dependencies of the package upgraded?',\r\n    super.shortDescription = 'Everything is upgraded',\r\n    super.suggestion = 'Not upgraded yet. Please run »gg do upgrade.«',\r\n    super.stateKey = 'doCommit',\r\n    IsUpgraded? isUpgraded,\r\n  }) : _isUpgraded = isUpgraded ?? IsUpgraded(ggLog: ggLog);\r\n\r\n  // ...........................................................................\r\n  /// Returns previously set value\r\n  @override\r\n  Future<bool> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? majorVersions,\r\n  }) async {\r\n    /// Is everything upgraded?\r\n    final isUpgraded = await _isUpgraded.get(\r\n      directory: directory,\r\n      ggLog: ggLog,\r\n      majorVersions: majorVersions,\r\n    );\r\n\r\n    return isUpgraded;\r\n  }\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  final IsUpgraded _isUpgraded;\r\n}\r\n\r\n/// Mock for [DidUpgrade]\r\nclass MockDidUpgrade extends MockDidCommand implements DidUpgrade {\r\n  // ...........................................................................\r\n  /// Mocks the result of the get command\r\n  @override\r\n  void mockGet({\r\n    required bool result,\r\n    Directory? directory,\r\n    GgLog? ggLog,\r\n    bool? majorVersions,\r\n    bool doThrow = false,\r\n    String? message,\r\n  }) {\r\n    when(\r\n      () => get(\r\n        ggLog: ggLog ?? any(named: 'ggLog'),\r\n        directory: any(\r\n          named: 'directory',\r\n          that: predicate<Directory>(\r\n            (d) => directory == null || d.path == directory.path,\r\n          ),\r\n        ),\r\n        majorVersions: majorVersions,\r\n      ),\r\n    ).thenAnswer((invocation) async {\r\n      return defaultReaction(\r\n        doThrow: doThrow,\r\n        invocation: invocation,\r\n        result: result,\r\n        message: message,\r\n      );\r\n    });\r\n  }\r\n}\r\n\n\nlib\\src\\commands\\did\\did_push.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/src/tools/did_command.dart';\r\n\r\n/// Are all changes pushed to the remote repository?\r\nclass DidPush extends DidCommand {\r\n  /// Constructor\r\n  DidPush({\r\n    super.name = 'push',\r\n    super.description = 'Are all changes pushed to the remote repository?',\r\n    super.shortDescription = 'Changes are pushed to the git remote',\r\n    super.suggestion = 'Please run »gg do push«.',\r\n    super.stateKey = 'doPush',\r\n    required super.ggLog,\r\n  });\r\n}\r\n\r\n/// Mock for [DidPush]\r\nclass MockDidPush extends MockDidCommand implements DidPush {}\r\n\n\nlib\\src\\commands\\did\\did_publish.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/src/tools/did_command.dart';\r\n\r\n/// Everything is published to pub.dev or git?\r\nclass DidPublish extends DidCommand {\r\n  /// Constructor\r\n  DidPublish({\r\n    super.name = 'publish',\r\n    super.description = 'Everything is published to pub.dev or git?',\r\n    super.shortDescription = 'Package is published',\r\n    super.suggestion = 'Not yet published. Please run »gg do publish«.',\r\n    super.stateKey = 'doPublish',\r\n    required super.ggLog,\r\n  });\r\n}\r\n\r\n/// Mock for [DidPublish]\r\nclass MockDidPublish extends MockDidCommand implements DidPublish {}\r\n\n\nlib\\src\\commands\\did\\did_commit.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/src/tools/did_command.dart';\r\n\r\n/// Are all changes committed?\r\nclass DidCommit extends DidCommand {\r\n  /// Constructor\r\n  DidCommit({\r\n    required super.ggLog,\r\n    super.name = 'commit',\r\n    super.description = 'Are all changes committed?',\r\n    super.shortDescription = 'All changes are committed',\r\n    super.suggestion = 'Not committed yet. Please run »gg do commit«.',\r\n    super.stateKey = 'doCommit',\r\n  });\r\n}\r\n\r\n/// Mock for [DidCommit]\r\nclass MockDidCommit extends MockDidCommand implements DidCommit {}\r\n\n\nlib\\src\\commands\\check.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\n\r\n// .............................................................................\r\n/// Various checks for the source code\r\nclass Check extends Command<void> {\r\n  /// Constructor\r\n  Check({required this.ggLog, Checks? checks}) {\r\n    _initSubCommands(checks);\r\n  }\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// Then name of the command\r\n  @override\r\n  final name = 'check';\r\n\r\n  /// The description of the command\r\n  @override\r\n  final description = 'Various commands for checking the source code.';\r\n\r\n  // ...........................................................................\r\n  void _initSubCommands(Checks? checks) {\r\n    checks = checks ?? Checks(ggLog: ggLog);\r\n    for (final check in checks.all) {\r\n      addSubcommand(check);\r\n    }\r\n  }\r\n}\r\n\n\nlib\\src\\commands\\check\\pana.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:convert';\r\nimport 'dart:io';\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\nimport 'package:mocktail/mocktail.dart' as mocktail;\r\n\r\n// #############################################################################\r\ntypedef _TaskResult = (int, List<String>, List<String>);\r\n\r\n// #############################################################################\r\n\r\n/// Runs dart pana on the source code\r\nclass Pana extends DirCommand<void> {\r\n  /// Constructor\r\n  Pana({\r\n    required super.ggLog,\r\n    this.processWrapper = const GgProcessWrapper(),\r\n    PublishTo? publishTo,\r\n    bool? publishedOnly,\r\n  }) : _publishTo = publishTo ?? PublishTo(ggLog: ggLog),\r\n       _publishedOnlyFromConstructor = publishedOnly,\r\n       super(name: 'pana', description: 'Runs »dart run pana«.') {\r\n    _addArgs();\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Executes the command\r\n  @override\r\n  Future<void> get({\r\n    required Directory directory,\r\n    required GgLog ggLog,\r\n    bool? publishedOnly,\r\n  }) async {\r\n    await check(directory: directory);\r\n    publishedOnly ??=\r\n        _publishedOnlyFromArgs ?? _publishedOnlyFromConstructor ?? false;\r\n\r\n    final statusPrinter = GgStatusPrinter<ProcessResult>(\r\n      ggLog: ggLog,\r\n      message: 'Running pana',\r\n    );\r\n\r\n    // Pana will only run if the package is to be published to pub.dev\r\n    if (publishedOnly) {\r\n      final isPublished =\r\n          await _publishTo.fromDirectory(directory) == 'pub.dev';\r\n      if (!isPublished) {\r\n        statusPrinter.logStatus(GgStatusPrinterStatus.success);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Announce the command\r\n    statusPrinter.logStatus(GgStatusPrinterStatus.running);\r\n    final result = await _task(directory);\r\n    final (code, messages, errors) = result;\r\n    final success = code == 0;\r\n\r\n    statusPrinter.logStatus(\r\n      success ? GgStatusPrinterStatus.success : GgStatusPrinterStatus.error,\r\n    );\r\n\r\n    if (!success) {\r\n      _logErrors(messages, errors);\r\n    }\r\n\r\n    if (code != 0) {\r\n      throw Exception(\r\n        'Pana failed. Run \"${blue('pana')}\" again to see details.',\r\n      );\r\n    }\r\n  }\r\n\r\n  /// The process wrapper used to execute shell processes\r\n  final GgProcessWrapper processWrapper;\r\n\r\n  // ######################\r\n  // Private\r\n  // ######################\r\n\r\n  final PublishTo _publishTo;\r\n\r\n  // ...........................................................................\r\n  void _logErrors(List<String> messages, List<String> errors) {\r\n    final errorMsg = errors.where((e) => e.isNotEmpty).join('\\n');\r\n    final stdoutMsg = messages.where((e) => e.isNotEmpty).join('\\n');\r\n\r\n    if (errorMsg.isNotEmpty) {\r\n      ggLog(errorMsg); // coverage:ignore-line\r\n    }\r\n    if (stdoutMsg.isNotEmpty) {\r\n      ggLog(stdoutMsg);\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  List<String> _readProblems(Map<String, dynamic> jsonOutput) {\r\n    final problems = <String>[];\r\n    final sections = jsonOutput['report']['sections'] as List<dynamic>;\r\n    final failedSections = sections.where(\r\n      (section) => section['status'] == 'failed',\r\n    );\r\n\r\n    for (final section in failedSections) {\r\n      final summary = section['summary'] as String;\r\n      final errorPoints = summary\r\n          .split('###')\r\n          .where((element) => element.contains('[x]'));\r\n\r\n      for (final errorPoint in errorPoints) {\r\n        final parts = errorPoint.split('\\n').map((e) => e.trim());\r\n\r\n        final title = parts.first;\r\n        final details = parts.skip(1);\r\n\r\n        final titleRed = red(title);\r\n        final detailsGray = details.map((e) => brightBlack(e)).join('\\n');\r\n        problems.add('\\n$titleRed$detailsGray');\r\n      }\r\n    }\r\n    return problems;\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<_TaskResult> _task(Directory dir) async {\r\n    // Make sure pana is installed\r\n    await _installPana();\r\n\r\n    // Run 'pana' and capture the output\r\n    final pana = Platform.isWindows ? 'pana.bat' : 'pana';\r\n    final result = await processWrapper.run(pana, [\r\n      '--no-warning',\r\n      '--json',\r\n      '--no-dartdoc', // dartdoc is enforced using analysis_options.yaml\r\n    ], workingDirectory: dir.path);\r\n\r\n    try {\r\n      // Parse the JSON output to get the score\r\n      final jsonOutput =\r\n          jsonDecode(result.stdout.toString()) as Map<String, dynamic>;\r\n      final grantedPoints = jsonOutput['scores']['grantedPoints'];\r\n      final maxPoints = jsonOutput['scores']['maxPoints'];\r\n      final complete = grantedPoints == maxPoints;\r\n      final points = '$grantedPoints/$maxPoints';\r\n\r\n      // Check if the score is less than 140\r\n      if (!complete) {\r\n        final errors = _readProblems(jsonOutput);\r\n\r\n        return (1, <String>[], errors);\r\n      } else {\r\n        final messages = ['All pub points achieved: $points'];\r\n        return (0, <String>[], messages);\r\n      }\r\n    } catch (e) {\r\n      return (1, ['Error parsing pana output: $e'], <String>[]);\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  bool? get _publishedOnlyFromArgs => argResults?['published-only'] as bool?;\r\n\r\n  // ...........................................................................\r\n  final bool? _publishedOnlyFromConstructor;\r\n\r\n  // ...........................................................................\r\n  void _addArgs() {\r\n    argParser.addFlag(\r\n      'published-only',\r\n      help: 'Check only packages published to pub.dev.',\r\n      negatable: true,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  /// Returns true if pana is installed\r\n  Future<bool> _isPanaInstalled() async {\r\n    // If a new version of pana is available, it needs to be updated.\r\n    final result = await processWrapper.run('dart', ['pub', 'global', 'list']);\r\n\r\n    if (result.exitCode != 0) {\r\n      throw Exception('Failed to check if pana is installed: ${result.stderr}');\r\n    }\r\n\r\n    return result.stdout.toString().contains(RegExp(r'[\\n^\\s]+pana\\s+'));\r\n  }\r\n\r\n  // ...........................................................................\r\n  Future<void> _installPana() async {\r\n    if (await _isPanaInstalled()) {\r\n      return;\r\n    }\r\n\r\n    final result = await processWrapper.run('dart', [\r\n      'pub',\r\n      'global',\r\n      'activate',\r\n      'pana',\r\n    ]);\r\n\r\n    if (result.exitCode != 0) {\r\n      ggLog(result.stderr.toString());\r\n      throw Exception('Failed to install pana: ${result.stderr}');\r\n    }\r\n  }\r\n}\r\n\r\n// .............................................................................\r\n/// A mocktail mock\r\nclass MockPana extends mocktail.Mock implements Pana {}\r\n\n\nlib\\src\\commands\\check\\format.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_is_github/gg_is_github.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\nimport 'package:gg_test/gg_test.dart';\r\nimport 'package:mocktail/mocktail.dart' as mocktail;\r\n\r\n// #############################################################################\r\n\r\n/// Runs dart format on the source code\r\nclass Format extends DirCommand<void> {\r\n  /// Constructor\r\n  Format({required super.ggLog, this.processWrapper = const GgProcessWrapper()})\r\n    : super(name: 'format', description: 'Runs »dart format«.');\r\n\r\n  // ...........................................................................\r\n  /// Executes the command\r\n  @override\r\n  Future<void> get({required Directory directory, required GgLog ggLog}) async {\r\n    await check(directory: directory);\r\n\r\n    final statusPrinter = GgStatusPrinter<ProcessResult>(\r\n      ggLog: ggLog,\r\n      message: 'Running \"dart format\"',\r\n    );\r\n\r\n    statusPrinter.logStatus(GgStatusPrinterStatus.running);\r\n\r\n    final result = await processWrapper.run('dart', [\r\n      'format',\r\n      '.',\r\n      '-o',\r\n      'write',\r\n      '--set-exit-if-changed',\r\n    ], workingDirectory: directory.path);\r\n\r\n    if (result.exitCode == 0) {\r\n      statusPrinter.logStatus(GgStatusPrinterStatus.success);\r\n    }\r\n\r\n    if (result.exitCode != 0) {\r\n      final stdErr = result.stderr as String;\r\n      final stdOut = result.stdout as String;\r\n      final std = '$stdErr\\n$stdOut';\r\n\r\n      final files = ErrorInfoReader().filePathes(std);\r\n\r\n      // When running on git hub, log the file that have been changed\r\n      if (isGitHub && files.isNotEmpty) {\r\n        statusPrinter.logStatus(GgStatusPrinterStatus.error);\r\n\r\n        // Log hint\r\n        ggLog(yellow('The following files were formatted:'));\r\n        final filesRed = files.map((e) => '- ${red(e)}').join('\\n');\r\n        ggLog(filesRed);\r\n\r\n        throw Exception('dart format failed.');\r\n      }\r\n\r\n      // When no files have changed, but an error occurred log the error\r\n      if (files.isEmpty) {\r\n        statusPrinter.logStatus(GgStatusPrinterStatus.error);\r\n        ggLog(brightBlack('std'));\r\n        throw Exception('dart format failed.');\r\n      }\r\n\r\n      statusPrinter.logStatus(GgStatusPrinterStatus.success);\r\n    }\r\n  }\r\n\r\n  /// The process wrapper used to execute shell processes\r\n  final GgProcessWrapper processWrapper;\r\n}\r\n\r\n// .............................................................................\r\n/// A mocktail mock\r\nclass MockFormat extends mocktail.Mock implements Format {}\r\n\n\nlib\\src\\commands\\check\\analyze.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_status_printer/gg_status_printer.dart';\r\nimport 'package:gg_test/gg_test.dart';\r\nimport 'package:mocktail/mocktail.dart' as mocktail;\r\n\r\n// #############################################################################\r\n\r\n/// Runs dart analyze on the source code\r\nclass Analyze extends DirCommand<void> {\r\n  /// Constructor\r\n  Analyze({\r\n    required super.ggLog,\r\n    this.processWrapper = const GgProcessWrapper(),\r\n  }) : super(name: 'analyze', description: 'Runs »dart analyze«.');\r\n\r\n  // ...........................................................................\r\n  /// Executes the command\r\n  @override\r\n  Future<void> get({required Directory directory, required GgLog ggLog}) async {\r\n    await check(directory: directory);\r\n\r\n    final statusPrinter = GgStatusPrinter<ProcessResult>(\r\n      ggLog: ggLog,\r\n      message: 'Running \"dart analyze\"',\r\n    );\r\n\r\n    statusPrinter.logStatus(GgStatusPrinterStatus.running);\r\n\r\n    final result = await processWrapper.run('dart', [\r\n      'analyze',\r\n      '--fatal-infos',\r\n      '--fatal-warnings',\r\n    ], workingDirectory: directory.path);\r\n\r\n    statusPrinter.logStatus(\r\n      result.exitCode == 0\r\n          ? GgStatusPrinterStatus.success\r\n          : GgStatusPrinterStatus.error,\r\n    );\r\n\r\n    if (result.exitCode != 0) {\r\n      final files = [\r\n        ...ErrorInfoReader().filePathes(result.stderr as String),\r\n        ...ErrorInfoReader().filePathes(result.stdout as String),\r\n      ];\r\n\r\n      // Log hint\r\n      ggLog(yellow('There are analyzer errors:'));\r\n\r\n      // Log files\r\n      final filesRed = files.map((e) => red('- $e')).join('\\n');\r\n      ggLog(filesRed);\r\n\r\n      throw Exception(\r\n        'Analyze failed. Run \"${blue('dart analyze')}\" to see details.',\r\n      );\r\n    }\r\n  }\r\n\r\n  /// The process wrapper used to execute shell processes\r\n  final GgProcessWrapper processWrapper;\r\n}\r\n\r\n// .............................................................................\r\n/// A mocktail mock\r\nclass MockAnalyze extends mocktail.Mock implements Analyze {}\r\n\n\nlib\\src\\commands\\can.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/src/commands/can/can_commit.dart';\r\nimport 'package:gg/src/commands/can/can_publish.dart';\r\nimport 'package:gg/src/commands/can/can_push.dart';\r\nimport 'package:gg/src/commands/can/can_merge.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\n\r\n// .............................................................................\r\n/// Various checks for the source code\r\nclass Can extends Command<void> {\r\n  /// Constructor\r\n  Can({required this.ggLog, DepsOfCan? deps}) {\r\n    deps ??= DepsOfCan(ggLog: ggLog);\r\n    _initSubCommands(deps);\r\n  }\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// Then name of the command\r\n  @override\r\n  final name = 'can';\r\n\r\n  /// The description of the command\r\n  @override\r\n  final description = 'Checks if you can commit, push, publish, merge, ....';\r\n\r\n  // ...........................................................................\r\n  void _initSubCommands(DepsOfCan deps) {\r\n    addSubcommand(deps.canCommit);\r\n    addSubcommand(deps.canPush);\r\n    addSubcommand(deps.canPublish);\r\n    addSubcommand(deps.canMerge);\r\n  }\r\n}\r\n\r\n// .............................................................................\r\n/// Dependencies for the can command (commit, push, publish, merge)\r\nclass DepsOfCan {\r\n  /// Constructor\r\n  DepsOfCan({\r\n    required this.ggLog,\r\n    CanCommit? commit,\r\n    CanPush? push,\r\n    CanPublish? publish,\r\n    CanMerge? merge,\r\n  }) : canCommit = commit ?? CanCommit(ggLog: ggLog),\r\n       canPush = push ?? CanPush(ggLog: ggLog),\r\n       canPublish = publish ?? CanPublish(ggLog: ggLog),\r\n       canMerge = merge ?? CanMerge(ggLog: ggLog);\r\n\r\n  /// The log function\r\n  final GgLog ggLog;\r\n\r\n  /// The can commit command\r\n  final CanCommit canCommit;\r\n\r\n  /// The can push command\r\n  final CanPush canPush;\r\n\r\n  /// The can publish command\r\n  final CanPublish canPublish;\r\n\r\n  /// The can merge command\r\n  final CanMerge canMerge;\r\n}\r\n\n\nlib\\src\\commands\\can\\can_merge.dart:\n// @license\r\n// Copyright (c) 2025 Göran Hegenberg. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_merge/gg_merge.dart' as gg_merge;\r\nimport 'package:gg_args/gg_args.dart';\r\n\r\n/// Are all preconditions for merging to main fulfilled?\r\nclass CanMerge extends CommandCluster {\r\n  /// Constructor\r\n  CanMerge({\r\n    required super.ggLog,\r\n    gg_merge.CanMerge? canMerge,\r\n    super.name = 'merge',\r\n    super.description = 'Are all preconditions for merging main fulfilled?',\r\n    super.shortDescription = 'Can merge?',\r\n    super.stateKey = 'canMerge',\r\n  }) : super(commands: [canMerge ?? gg_merge.CanMerge(ggLog: ggLog)]);\r\n}\r\n\r\n/// A mocktail mock\r\nclass MockCanMerge extends MockDirCommand<void> implements CanMerge {}\r\n\n\nlib\\src\\commands\\can\\can_publish.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg_changelog/gg_changelog.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\n\r\n/// Are the last changes ready to be published?\r\nclass CanPublish extends CommandCluster {\r\n  /// Constructor\r\n  CanPublish({\r\n    required super.ggLog,\r\n    super.name = 'publish',\r\n    super.description = 'Are the last changes ready to be published?',\r\n    super.shortDescription = 'Can publish?',\r\n    super.stateKey = 'canPublish',\r\n    DidCommit? didCommit,\r\n    IsVersionPrepared? isVersionPrepared,\r\n    Pana? pana,\r\n    HasRightFormat? changeLogHasRightFormat,\r\n  }) : super(\r\n         commands: [\r\n           isVersionPrepared ??\r\n               IsVersionPrepared(ggLog: ggLog, treatUnpublishedAsOk: true),\r\n           changeLogHasRightFormat ?? HasRightFormat(ggLog: ggLog),\r\n           didCommit ?? DidCommit(ggLog: ggLog),\r\n           pana ?? Pana(ggLog: ggLog, publishedOnly: true),\r\n         ],\r\n       );\r\n}\r\n\r\n// .............................................................................\r\n/// A mocktail mock\r\nclass MockCanPublish extends MockDirCommand<void> implements CanPublish {}\r\n\n\nlib\\src\\commands\\can\\can_upgrade.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\n\r\n/// Is the package ready to get a dependeny upgrade?\r\nclass CanUpgrade extends CommandCluster {\r\n  /// Constructor\r\n  CanUpgrade({\r\n    required super.ggLog,\r\n    Checks? checkCommands,\r\n    super.name = 'upgrade',\r\n    super.shortDescription = 'Can upgrade?',\r\n    super.description = 'Is the package ready to get a dependeny upgrade?',\r\n    super.stateKey = 'canUpgrade',\r\n    DidPublish? didPublish,\r\n  }) : super(\r\n         commands: [], // Currently we can upgrade always\r\n       );\r\n}\r\n\r\n// .............................................................................\r\n/// A mocktail mock\r\nclass MockCanUpgrade extends MockDirCommand<void> implements CanUpgrade {}\r\n\n\ntest\\vscode\\launch_json_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:convert';\r\nimport 'dart:io';\r\n\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  // #########################################################################\r\n  group('.vscode/launch.json', () {\r\n    test('pathes in launch.json', () {\r\n      const String launchJsonPath = '.vscode/launch.json';\r\n      final String launchJson = File(\r\n        launchJsonPath,\r\n      ).readAsStringSync().replaceAll(RegExp(r'//.*'), '');\r\n\r\n      final parsedLaunchJson = jsonDecode(launchJson) as Map<String, dynamic>;\r\n\r\n      // Ensure there is a configuration for executing bin/gg.dart\r\n      final configurations =\r\n          parsedLaunchJson['configurations'] as List<dynamic>;\r\n\r\n      final gg = configurations.firstWhere(\r\n        (dynamic configuration) =>\r\n            configuration['name'].toString() == 'gg.dart',\r\n      );\r\n\r\n      expect(gg, isNotNull, reason: 'Item for executing bin/gg.dart not found');\r\n\r\n      expect(gg['name'], 'gg.dart');\r\n      expect(gg['type'], 'dart');\r\n      expect(gg['request'], 'launch');\r\n\r\n      // Ensure there is a coniguration for executing the current file\r\n      final currentFile = parsedLaunchJson['configurations'].firstWhere(\r\n        (dynamic configuration) => configuration['name'] == 'Current File',\r\n      );\r\n      expect(\r\n        currentFile,\r\n        isNotNull,\r\n        reason: 'Item for executing current file not found',\r\n      );\r\n      expect(currentFile['type'], 'dart');\r\n      expect(currentFile['request'], 'launch');\r\n      expect(currentFile['program'], r'${file}');\r\n\r\n      // Test other configurations\r\n      for (final configuration\r\n          in parsedLaunchJson['configurations'] as Iterable) {\r\n        final program = configuration['program'].toString();\r\n        expect(program, isNotNull);\r\n        expect(program, isNotEmpty);\r\n        if (program.contains('{workspaceFolder}')) {\r\n          final resolved = program.replaceAll(r'${workspaceFolder}', '.');\r\n          final file = File(resolved);\r\n          expect(file.existsSync(), isTrue);\r\n          final content = file.readAsStringSync();\r\n          if (file.path.endsWith('.dart')) {\r\n            expect(content, contains('main('));\r\n          }\r\n        }\r\n      }\r\n    });\r\n  });\r\n}\r\n\n\ntest\\tools\\gg_state_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:convert';\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/tools/gg_state.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory dLocal;\r\n  late Directory dRemote;\r\n  late GgState ggState;\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n  late CommitCount commitCount;\r\n  late ModifiedFiles modifiedFiles;\r\n\r\n  // ...........................................................................\r\n  Future<void> initCommand() async {\r\n    ggState = GgState(ggLog: messages.add);\r\n    await initGit(dLocal);\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    messages.clear();\r\n    dLocal = await initTestDir();\r\n    dRemote = await initTestDir();\r\n\r\n    await initGit(dLocal);\r\n    await initRemoteGit(dRemote);\r\n\r\n    await initCommand();\r\n    await addPubspecFileWithoutCommitting(dLocal, version: '1.0.0');\r\n    await commitPubspecFile(dLocal);\r\n\r\n    commitCount = CommitCount(ggLog: messages.add);\r\n    modifiedFiles = ModifiedFiles(ggLog: messages.add);\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() async {\r\n    await dLocal.delete(recursive: true);\r\n    await dRemote.delete(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('CheckState', () {\r\n    group('writeSuccess(directory, success)', () {\r\n      group('with success == true', () {\r\n        test('should write last change hash to .gg.json', () async {\r\n          await addAndCommitSampleFile(dLocal);\r\n\r\n          // Get last changes hash\r\n          final hash = await LastChangesHash(\r\n            ggLog: messages.add,\r\n          ).get(directory: dLocal, ggLog: messages.add);\r\n\r\n          // Set the state\r\n          await ggState.writeSuccess(directory: dLocal, key: 'can-commit');\r\n\r\n          // Check the file\r\n          final checkJson = File('${dLocal.path}/.gg.json');\r\n          await expectLater(await checkJson.exists(), isTrue);\r\n          final contentsString = await checkJson.readAsString();\r\n          final contents = json.decode(contentsString);\r\n          expect(contents['can-commit']['success']['hash'], hash);\r\n        });\r\n      });\r\n\r\n      group('should ammend changes to .gg.json to the last commit', () {\r\n        test('when previous changes were not already pushed', () async {\r\n          // Let's create an inital commit\r\n          await addAndCommitSampleFile(dLocal, fileName: 'file1.txt');\r\n\r\n          // Check the inital commit count\r\n          final initialCommitCount = await commitCount.get(\r\n            directory: dLocal,\r\n            ggLog: ggLog,\r\n          );\r\n          expect(initialCommitCount, 2);\r\n\r\n          // file1.txt should be shown as modified in the last commit\r\n          expect(\r\n            await modifiedFiles.get(\r\n              directory: dLocal,\r\n              ggLog: ggLog,\r\n              force: true,\r\n            ),\r\n            ['file1.txt'],\r\n          );\r\n\r\n          // Run the command a first time\r\n          await ggState.writeSuccess(directory: dLocal, key: 'isCommitted');\r\n\r\n          // Because we have not pushed the changes yet,\r\n          // changes to gg.json should be ammended to the last commit\r\n\r\n          // - i.e. commit count has not changed\r\n          final commitCount0 = await commitCount.get(\r\n            directory: dLocal,\r\n            ggLog: ggLog,\r\n          );\r\n          expect(commitCount0, 2);\r\n\r\n          // - i.e. file1.txt should be shown as modified in the last commit\r\n          expect(\r\n            await modifiedFiles.get(\r\n              directory: dLocal,\r\n              ggLog: ggLog,\r\n              force: true,\r\n            ),\r\n            ['.gg.json', 'file1.txt'],\r\n          );\r\n        });\r\n      });\r\n\r\n      group('should create a new commit', () {\r\n        test('when previous changes were already pushed', () async {\r\n          // Let's connect the local and remote repositories\r\n          await addRemoteToLocal(local: dLocal, remote: dRemote);\r\n\r\n          // Let's create an inital commit\r\n          await addAndCommitSampleFile(dLocal, fileName: 'file1.txt');\r\n\r\n          // Check the inital commit count\r\n          final initialCommitCount = await commitCount.get(\r\n            directory: dLocal,\r\n            ggLog: ggLog,\r\n          );\r\n          expect(initialCommitCount, isNot(0));\r\n\r\n          // file1.txt should be shown as modified in the last commit\r\n          expect(\r\n            await modifiedFiles.get(\r\n              directory: dLocal,\r\n              ggLog: ggLog,\r\n              force: true,\r\n            ),\r\n            ['file1.txt'],\r\n          );\r\n\r\n          // Push the changes\r\n          await Process.run('git', ['push'], workingDirectory: dLocal.path);\r\n\r\n          // Run the command a first time\r\n          await ggState.writeSuccess(directory: dLocal, key: 'isCommitted');\r\n\r\n          // Because we have pushed the changes already,\r\n          // changes to gg.json should be commited as a new commit\r\n\r\n          // - i.e. commit count has changed\r\n          final commitCount0 = await commitCount.get(\r\n            directory: dLocal,\r\n            ggLog: ggLog,\r\n          );\r\n          expect(commitCount0, initialCommitCount + 1);\r\n\r\n          // - i.e. only .gg.json should be shown as modified in the last commit\r\n          expect(\r\n            await modifiedFiles.get(\r\n              directory: dLocal,\r\n              ggLog: ggLog,\r\n              force: true,\r\n            ),\r\n            ['.gg.json'],\r\n          );\r\n\r\n          // Executing the cluster again should not change anything\r\n          await ggState.writeSuccess(directory: dLocal, key: 'isCommitted');\r\n\r\n          final commitCount1 = await commitCount.get(\r\n            directory: dLocal,\r\n            ggLog: ggLog,\r\n          );\r\n          expect(commitCount1, initialCommitCount + 1);\r\n        });\r\n      });\r\n\r\n      group('should throw', () {\r\n        test('if nothing is comitted', () async {\r\n          await dLocal.delete(recursive: true);\r\n          dLocal = await initTestDir();\r\n          await initGit(dLocal);\r\n\r\n          expect(\r\n            () async => await ggState.writeSuccess(\r\n              directory: dLocal,\r\n              key: 'isCommitted',\r\n            ),\r\n            throwsA(\r\n              isA<Exception>().having(\r\n                (e) => e.toString(),\r\n                'toString()',\r\n                'Exception: '\r\n                    'There must be at least one commit in the repository.',\r\n              ),\r\n            ),\r\n          );\r\n        });\r\n      });\r\n    });\r\n\r\n    group('readSuccess(directory, key, ggLog)', () {\r\n      group('should return', () {\r\n        group('false', () {\r\n          test('if no .gg.json exists', () async {\r\n            expect(await File('${dLocal.path}/.gg.json').exists(), isFalse);\r\n            final result = await ggState.readSuccess(\r\n              directory: dLocal,\r\n              ggLog: messages.add,\r\n              key: 'can-commit',\r\n            );\r\n            expect(result, isFalse);\r\n          });\r\n\r\n          test('if .gg.json is empty', () async {\r\n            File('${dLocal.path}/.gg.json').writeAsStringSync('{}');\r\n\r\n            final result = await ggState.readSuccess(\r\n              directory: dLocal,\r\n              ggLog: messages.add,\r\n              key: 'can-commit',\r\n            );\r\n            expect(result, isFalse);\r\n          });\r\n\r\n          test('if last success hash is not current hash', () async {\r\n            // Set the state\r\n            await ggState.writeSuccess(directory: dLocal, key: 'can-commit');\r\n\r\n            // Change the file\r\n            await addAndCommitSampleFile(dLocal);\r\n\r\n            final result = await ggState.readSuccess(\r\n              directory: dLocal,\r\n              ggLog: messages.add,\r\n              key: 'can-commit',\r\n            );\r\n            expect(result, isFalse);\r\n          });\r\n        });\r\n\r\n        group('true', () {\r\n          test('if last success hash is current hash', () async {\r\n            // Commit something\r\n            await addAndCommitSampleFile(dLocal, fileName: 'file0.txt');\r\n\r\n            // Write success after everything is committed\r\n            await ggState.writeSuccess(directory: dLocal, key: 'can-commit');\r\n\r\n            // Read succes -> It should be true\r\n            final result = await ggState.readSuccess(\r\n              directory: dLocal,\r\n              ggLog: messages.add,\r\n              key: 'can-commit',\r\n            );\r\n            expect(result, isTrue);\r\n\r\n            // Make a modification\r\n            await File('${dLocal.path}/file0.txt').writeAsString('modified');\r\n\r\n            // Read success -> It should be false\r\n            final result2 = await ggState.readSuccess(\r\n              directory: dLocal,\r\n              ggLog: messages.add,\r\n              key: 'can-commit',\r\n            );\r\n            expect(result2, isFalse);\r\n\r\n            // Write success again\r\n            await ggState.writeSuccess(directory: dLocal, key: 'can-commit');\r\n\r\n            // Read success -> It should be true\r\n            final result3 = await ggState.readSuccess(\r\n              directory: dLocal,\r\n              ggLog: messages.add,\r\n              key: 'can-commit',\r\n            );\r\n            expect(result3, isTrue);\r\n\r\n            // Commit the last changes.\r\n            // This should not change the success state.\r\n            await commitFile(dLocal, 'file0.txt');\r\n\r\n            // Read success -> It should be true\r\n            final result4 = await ggState.readSuccess(\r\n              directory: dLocal,\r\n              ggLog: messages.add,\r\n              key: 'can-commit',\r\n            );\r\n            expect(result4, isTrue);\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    group('updateHash()', () {\r\n      group('replaces the hash in .gg.json with the current hash', () {\r\n        test('when current hash is different', () async {\r\n          // Get last changes hash\r\n          final hash = await LastChangesHash(\r\n            ggLog: messages.add,\r\n          ).get(directory: dLocal, ggLog: messages.add);\r\n\r\n          // Set the state\r\n          await ggState.writeSuccess(directory: dLocal, key: 'can-commit');\r\n\r\n          // Change the file\r\n          await addAndCommitSampleFile(dLocal);\r\n\r\n          // Because of the change, ggState.readSuccess should return false\r\n          final result = await ggState.readSuccess(\r\n            directory: dLocal,\r\n            ggLog: messages.add,\r\n            key: 'can-commit',\r\n          );\r\n          expect(result, isFalse);\r\n\r\n          // Update the previous hash\r\n          await ggState.updateHash(hash: hash, directory: dLocal);\r\n\r\n          // Now ggState.readSuccess should return true again\r\n          final result1 = await ggState.readSuccess(\r\n            directory: dLocal,\r\n            ggLog: messages.add,\r\n            key: 'can-commit',\r\n          );\r\n          expect(result1, isTrue);\r\n        });\r\n\r\n        test('but not when the hash has not changed', () async {\r\n          // Get last changes hash\r\n          final hash = await LastChangesHash(\r\n            ggLog: messages.add,\r\n          ).get(directory: dLocal, ggLog: messages.add);\r\n\r\n          // Update the previous hash\r\n          await ggState.updateHash(hash: hash, directory: dLocal);\r\n        });\r\n      });\r\n    });\r\n\r\n    group('reset(directory)', () {\r\n      test('should reset success state', () async {\r\n        // Set the state\r\n        await ggState.writeSuccess(directory: dLocal, key: 'can-commit');\r\n\r\n        expect(\r\n          await ggState.readSuccess(\r\n            directory: dLocal,\r\n            ggLog: messages.add,\r\n            key: 'can-commit',\r\n          ),\r\n          isTrue,\r\n        );\r\n\r\n        // Reset the state\r\n        await ggState.reset(directory: dLocal);\r\n\r\n        // Check the file\r\n        expect(\r\n          await ggState.readSuccess(\r\n            directory: dLocal,\r\n            ggLog: messages.add,\r\n            key: 'can-commit',\r\n          ),\r\n          isFalse,\r\n        );\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\tools\\did_command_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\nimport 'package:gg/src/tools/did_command.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  late DidCommand didCommand;\r\n  final messages = <String>[];\r\n\r\n  // ...........................................................................\r\n  void initDidCommand() {\r\n    didCommand = DidCommand(\r\n      name: 'do',\r\n      description: 'description',\r\n      shortDescription: 'Did do?',\r\n      suggestion: 'Please run »gg do«.',\r\n      ggLog: messages.add,\r\n      stateKey: 'did-do',\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    messages.clear();\r\n    d = Directory.systemTemp.createTempSync();\r\n    await initGit(d);\r\n    await addAndCommitSampleFile(d);\r\n    initDidCommand();\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() {\r\n    d.deleteSync(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('DidCommand', () {\r\n    group('exec(directory, ggLog)', () {\r\n      group('should return true', () {\r\n        group('and print ✓', () {\r\n          test('when state was set to success before', () async {\r\n            await didCommand.state.writeSuccess(directory: d, key: 'did-do');\r\n\r\n            await didCommand.exec(directory: d, ggLog: messages.add);\r\n            expect(messages[0], contains('⌛️ Did do?'));\r\n            expect(messages[1], contains('✅ Did do?'));\r\n          });\r\n        });\r\n      });\r\n\r\n      group('should throw', () {\r\n        group('and print ❌', () {\r\n          test('when state was not set to success before', () async {\r\n            // Getting the state should throw\r\n            late String exceptionMessage;\r\n\r\n            try {\r\n              await didCommand.exec(directory: d, ggLog: messages.add);\r\n            } catch (e) {\r\n              exceptionMessage = e.toString();\r\n            }\r\n\r\n            expect(messages[0], contains('⌛️ Did do?'));\r\n            expect(messages[1], contains('❌ Did do?'));\r\n            expect(\r\n              exceptionMessage,\r\n              contains(\r\n                '${darkGray('Please run ')}${blue('gg do')}${darkGray('.')}',\r\n              ),\r\n            );\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    group('get(directory, ggLog)', () {\r\n      group('should return', () {\r\n        group('false', () {\r\n          test('if something has changed inbetween', () async {\r\n            await didCommand.state.writeSuccess(directory: d, key: 'did-do');\r\n\r\n            await addAndCommitSampleFile(\r\n              d,\r\n              fileName: 'another-file.txt',\r\n              content: 'another content',\r\n            );\r\n\r\n            final success = await didCommand.get(\r\n              directory: d,\r\n              ggLog: messages.add,\r\n            );\r\n\r\n            expect(success, isFalse);\r\n          });\r\n        });\r\n\r\n        group('true', () {\r\n          test(\r\n            'if a success state was saved and nothing has changed',\r\n            () async {\r\n              await didCommand.state.writeSuccess(directory: d, key: 'did-do');\r\n\r\n              final success = await didCommand.get(\r\n                directory: d,\r\n                ggLog: messages.add,\r\n              );\r\n\r\n              expect(success, isTrue);\r\n            },\r\n          );\r\n        });\r\n      });\r\n    });\r\n\r\n    group('set(directory, ggLog)', () {\r\n      test('should set the state to success', () async {\r\n        await didCommand.set(directory: d);\r\n\r\n        final success = await didCommand.get(directory: d, ggLog: messages.add);\r\n\r\n        expect(success, isTrue);\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\tools\\command_cluster_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:path/path.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n  late IsCommitted isCommitted;\r\n  late IsPushed isPushed;\r\n  late IsUpgraded isUpgraded;\r\n\r\n  late List<DirCommand<void>> commands;\r\n  late CommandCluster commandCluster;\r\n\r\n  setUp(() async {\r\n    // Init basics\r\n    messages.clear();\r\n    d = Directory.systemTemp.createTempSync();\r\n    await initGit(d);\r\n\r\n    // Init commands\r\n    isCommitted = MockIsCommitted();\r\n    isPushed = MockIsPushed();\r\n    isUpgraded = MockIsUpgraded();\r\n    commands = [isCommitted, isPushed, isUpgraded];\r\n\r\n    // Init command cluster\r\n    commandCluster = CommandCluster(\r\n      ggLog: ggLog,\r\n      commands: commands,\r\n      name: 'my-check',\r\n      description: 'A more detailed description.',\r\n      shortDescription: 'Do all check commands work?',\r\n      stateKey: 'my-check',\r\n    );\r\n\r\n    // Mock the commands\r\n    when(() => isCommitted.exec(directory: d, ggLog: ggLog)).thenAnswer((\r\n      _,\r\n    ) async {\r\n      ggLog('isCommitted');\r\n      return true;\r\n    });\r\n    when(() => isPushed.exec(directory: d, ggLog: ggLog)).thenAnswer((_) async {\r\n      ggLog('isPushed');\r\n      return true;\r\n    });\r\n    when(() => isUpgraded.exec(directory: d, ggLog: ggLog)).thenAnswer((\r\n      _,\r\n    ) async {\r\n      ggLog('isUpgraded');\r\n      return true;\r\n    });\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  group('CommandCluster', () {\r\n    group('exec(directory, log)', () {\r\n      group('with force == false', () {\r\n        test(\r\n          'should not run commands again that were successful before',\r\n          () async {\r\n            // Run the command a first time\r\n            // Should complain about missing commits\r\n            late String exception;\r\n            try {\r\n              await commandCluster.exec(directory: d, ggLog: ggLog);\r\n            } catch (e) {\r\n              exception = e.toString();\r\n            }\r\n\r\n            expect(messages[0], contains('Do all check commands work?'));\r\n            expect(messages[1], 'isCommitted');\r\n            expect(messages[2], 'isPushed');\r\n            expect(messages[3], 'isUpgraded');\r\n\r\n            expect(\r\n              exception,\r\n              'Exception: There must be at least one commit in the repository.',\r\n            );\r\n\r\n            // Make an initial commit\r\n            await addAndCommitSampleFile(d, fileName: 'file1.txt');\r\n\r\n            // Run command again\r\n            await commandCluster.exec(directory: d, ggLog: ggLog);\r\n            expect(messages[4], contains('Do all check commands work?'));\r\n            expect(messages[5], 'isCommitted');\r\n            expect(messages[6], 'isPushed');\r\n            expect(messages[7], 'isUpgraded');\r\n\r\n            // Run the command a second time.\r\n            // Should not run the commands again,\r\n            // because force is false\r\n            // and the commands were successful before.\r\n            await commandCluster.exec(directory: d, ggLog: ggLog);\r\n            expect(messages[8], contains('Do all check commands work?'));\r\n            expect(messages[9], '✅ Everything is fine.');\r\n          },\r\n        );\r\n      });\r\n\r\n      group('with force == true', () {\r\n        test('should run commands '\r\n            'no matter if they were successful before or not', () async {\r\n          await addAndCommitSampleFile(d, fileName: 'file1.txt');\r\n\r\n          // Run the command a first time\r\n          await commandCluster.exec(directory: d, ggLog: ggLog);\r\n          expect(messages[0], contains('Do all check commands work?'));\r\n          expect(messages[1], 'isCommitted');\r\n          expect(messages[2], 'isPushed');\r\n          expect(messages[3], 'isUpgraded');\r\n\r\n          // Run the command a second first time\r\n          await commandCluster.exec(directory: d, ggLog: ggLog, force: true);\r\n          expect(messages[4], contains('Do all check commands work?'));\r\n          expect(messages[5], 'isCommitted');\r\n          expect(messages[6], 'isPushed');\r\n          expect(messages[7], 'isUpgraded');\r\n        });\r\n      });\r\n\r\n      group('with save-state == true or (false)', () {\r\n        test('should (not) save the success state', () async {\r\n          await addAndCommitSampleFile(d, fileName: 'file1.txt');\r\n\r\n          final ggJson = await File(join(d.path, '.gg.json')).create();\r\n          final ggJsonBefore = await ggJson.readAsString();\r\n\r\n          // Run the command with save-state == false\r\n          await commandCluster.exec(\r\n            directory: d,\r\n            ggLog: ggLog,\r\n            force: true,\r\n            saveState: false,\r\n          );\r\n\r\n          // State should not be saved\r\n          final ggJsonAfterWithoutSave = await ggJson.readAsString();\r\n          expect(ggJsonAfterWithoutSave, ggJsonBefore);\r\n\r\n          // Run the command with save-state == true\r\n          await commandCluster.exec(\r\n            directory: d,\r\n            ggLog: ggLog,\r\n            force: true,\r\n            saveState: true,\r\n          );\r\n\r\n          // State should be saved\r\n          final ggJsonAfterWithSave = await ggJson.readAsString();\r\n          expect(ggJsonBefore, isNot(ggJsonAfterWithSave));\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\tools\\checks_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  final GgLog ggLog = messages.add;\r\n  final checks = Checks(ggLog: ggLog);\r\n\r\n  group('Checks', () {\r\n    group('all', () {\r\n      test('should provide a list of all checks', () {\r\n        expect(checks.all, hasLength(9));\r\n        expect(checks.all, [\r\n          checks.analyze,\r\n          checks.format,\r\n          checks.tests,\r\n          checks.pana,\r\n          checks.isPushed,\r\n          checks.isCommitted,\r\n          checks.isVersioned,\r\n          checks.isPublished,\r\n          checks.isUpgraded,\r\n        ]);\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\tools\\carriage_return_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:gg/src/tools/carriage_return.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  group('carriageReturn', () {\r\n    test('should have the right value', () {\r\n      // const CarriageReturn();\r\n      expect(carriageReturn, '\\x1b[1A\\x1b[2K');\r\n    });\r\n  });\r\n}\r\n\n\ntest\\gg_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg_capture_print/gg_capture_print.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:path/path.dart';\r\nimport 'package:recase/recase.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  const processWrapper = GgProcessWrapper();\r\n\r\n  setUp(() {\r\n    messages.clear();\r\n  });\r\n\r\n  group('gg()', () {\r\n    // #########################################################################\r\n    group('gg', () {\r\n      final gg = Gg(ggLog: messages.add, processWrapper: processWrapper);\r\n\r\n      final CommandRunner<void> runner = CommandRunner<void>(\r\n        'gg',\r\n        'Description goes here.',\r\n      )..addCommand(gg);\r\n\r\n      test('should allow to run the code from command line', () async {\r\n        final tmp = Directory.systemTemp.createTempSync();\r\n\r\n        await capturePrint(\r\n          ggLog: messages.add,\r\n          code: () =>\r\n              runner.run(['gg', 'check', 'analyze', '--input', tmp.path]),\r\n        );\r\n\r\n        await tmp.delete(recursive: true);\r\n        expect(messages.first, contains('⌛️ Running \"dart analyze\"'));\r\n        expect(messages.last, contains('✅ Running \"dart analyze\"'));\r\n      });\r\n\r\n      // .......................................................................\r\n      test('should show all sub commands', () async {\r\n        // Iterate all files in lib/src/commands\r\n        // and check if they are added to the command runner\r\n        // and if they are added to the help message\r\n        final subCommands = Directory('lib/src/commands')\r\n            .listSync(recursive: false)\r\n            .where((file) => file.path.endsWith('.dart'))\r\n            .map(\r\n              (e) => basename(e.path)\r\n                  .replaceAll('.dart', '')\r\n                  .replaceAll('_', '-')\r\n                  .replaceAll('gg-', ''),\r\n            )\r\n            .toList();\r\n\r\n        await capturePrint(\r\n          ggLog: messages.add,\r\n          code: () async => await runner.run(['gg', '--help']),\r\n        );\r\n\r\n        for (final subCommand in subCommands) {\r\n          final subCommandStr = subCommand.pascalCase;\r\n\r\n          expect(\r\n            hasLog(messages, subCommand),\r\n            isTrue,\r\n            reason:\r\n                '\\nMissing subcommand \"$subCommandStr\"\\n'\r\n                'Please open  \"lib/src/gg.dart\" and add\\n'\r\n                '\"addSubcommand($subCommandStr(ggLog: ggLog));',\r\n          );\r\n        }\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\data\\pana_success_report.json:\n{\r\n  \"createdAt\": \"2024-02-24T21:00:05.775956\",\r\n  \"runtimeInfo\": {\r\n    \"panaVersion\": \"0.22.1\",\r\n    \"sdkVersion\": \"3.4.0-140.0.dev\",\r\n    \"flutterVersions\": {\r\n      \"frameworkVersion\": \"3.20.0-7.0.pre.66\",\r\n      \"channel\": \"master\",\r\n      \"repositoryUrl\": \"https://github.com/flutter/flutter.git\",\r\n      \"frameworkRevision\": \"ea3d066237a5559d54ad778283e516e74af5e596\",\r\n      \"frameworkCommitDate\": \"2024-02-15 15:37:40 -0600\",\r\n      \"engineRevision\": \"3af336bfb2dfd9080c028fadcafca39a06e20e43\",\r\n      \"dartSdkVersion\": \"3.4.0 (build 3.4.0-140.0.dev)\",\r\n      \"devToolsVersion\": \"2.33.0-dev.6\",\r\n      \"flutterVersion\": \"3.20.0-7.0.pre.66\",\r\n      \"flutterRoot\": \"/Users/gatzsche/dev/flutter\"\r\n    }\r\n  },\r\n  \"packageName\": \"gg\",\r\n  \"packageVersion\": \"1.0.0\",\r\n  \"pubspec\": {\r\n    \"name\": \"gg\",\r\n    \"description\": \"Offers pre-commit checks like analyzing, linting, tests and coverage.\",\r\n    \"version\": \"1.0.0\",\r\n    \"repository\": \"https://github.com/inlavigo/gg.git\",\r\n    \"publish_to\": \"none\",\r\n    \"environment\": {\r\n      \"sdk\": \">=3.3.0<4.0.0\"\r\n    },\r\n    \"dependencies\": {\r\n      \"args\": \"^2.4.2\",\r\n      \"collection\": \"^1.18.0\",\r\n      \"colorize\": \"^3.0.0\",\r\n      \"dart_ping\": \"^9.0.1\",\r\n      \"path\": \"^1.8.0\",\r\n      \"recase\": \"^4.1.0\",\r\n      \"yaml\": \"^3.1.2\"\r\n    },\r\n    \"dev_dependencies\": {\r\n      \"lints\": \"^3.0.0\",\r\n      \"pana\": \"^0.22.1\",\r\n      \"test\": \"^1.24.0\"\r\n    }\r\n  },\r\n  \"licenseFile\": {\r\n    \"path\": \"LICENSE\",\r\n    \"name\": \"MIT\"\r\n  },\r\n  \"licenses\": [\r\n    {\r\n      \"path\": \"LICENSE\",\r\n      \"spdxIdentifier\": \"MIT\"\r\n    }\r\n  ],\r\n  \"allDependencies\": [\r\n    \"args\",\r\n    \"async\",\r\n    \"collection\",\r\n    \"colorize\",\r\n    \"dart_ping\",\r\n    \"lints\",\r\n    \"meta\",\r\n    \"pana\",\r\n    \"path\",\r\n    \"recase\",\r\n    \"source_span\",\r\n    \"string_scanner\",\r\n    \"term_glyph\",\r\n    \"test\",\r\n    \"yaml\"\r\n  ],\r\n  \"tags\": [\r\n    \"sdk:dart\",\r\n    \"sdk:flutter\",\r\n    \"platform:android\",\r\n    \"platform:ios\",\r\n    \"platform:windows\",\r\n    \"platform:linux\",\r\n    \"platform:macos\",\r\n    \"runtime:native-aot\",\r\n    \"runtime:native-jit\",\r\n    \"is:null-safe\",\r\n    \"is:dart3-compatible\",\r\n    \"license:mit\",\r\n    \"license:fsf-libre\",\r\n    \"license:osi-approved\"\r\n  ],\r\n  \"report\": {\r\n    \"sections\": [\r\n      {\r\n        \"id\": \"convention\",\r\n        \"title\": \"Follow Dart file conventions\",\r\n        \"grantedPoints\": 30,\r\n        \"maxPoints\": 30,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 10/10 points: Provide a valid `pubspec.yaml`\\n\\n\\n### [*] 5/5 points: Provide a valid `README.md`\\n\\n\\n### [*] 5/5 points: Provide a valid `CHANGELOG.md`\\n\\n\\n### [*] 10/10 points: Use an OSI-approved license\\n\\nDetected license: `MIT`.\"\r\n      },\r\n      {\r\n        \"id\": \"documentation\",\r\n        \"title\": \"Provide documentation\",\r\n        \"grantedPoints\": 20,\r\n        \"maxPoints\": 20,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 10/10 points: 20% or more of the public API has dartdoc comments\\n\\n6 out of 7 API elements (85.7 %) have documentation comments.\\n\\nSome symbols that are missing documentation: `gg`.\\n\\n### [*] 10/10 points: Package has an example\\n\"\r\n      },\r\n      {\r\n        \"id\": \"platform\",\r\n        \"title\": \"Platform support\",\r\n        \"grantedPoints\": 20,\r\n        \"maxPoints\": 20,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 20/20 points: Supports 5 of 6 possible platforms (**iOS**, **Android**, Web, **Windows**, **macOS**, **Linux**)\\n\\n* ✓ Android\\n* ✓ iOS\\n* ✓ Windows\\n* ✓ Linux\\n* ✓ macOS\\n\\nThese platforms are not supported:\\n\\n<details>\\n<summary>\\nPackage not compatible with platform Web\\n</summary>\\n\\nBecause:\\n* `package:gg/gg.dart` that imports:\\n* `package:gg/src/gg.dart` that imports:\\n* `package:gg/src/tools/is_github.dart` that imports:\\n* `dart:io`\\n</details>\"\r\n      },\r\n      {\r\n        \"id\": \"analysis\",\r\n        \"title\": \"Pass static analysis\",\r\n        \"grantedPoints\": 50,\r\n        \"maxPoints\": 50,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 50/50 points: code has no errors, warnings, lints, or formatting issues\\n\"\r\n      },\r\n      {\r\n        \"id\": \"dependency\",\r\n        \"title\": \"Support up-to-date dependencies\",\r\n        \"grantedPoints\": 20,\r\n        \"maxPoints\": 20,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 10/10 points: All of the package dependencies are supported in the latest version\\n\\n|Package|Constraint|Compatible|Latest|\\n|:-|:-|:-|:-|\\n|[`args`]|`^2.4.2`|2.4.2|2.4.2|\\n|[`collection`]|`^1.18.0`|1.18.0|1.18.0|\\n|[`colorize`]|`^3.0.0`|3.0.0|3.0.0|\\n|[`dart_ping`]|`^9.0.1`|9.0.1|9.0.1|\\n|[`path`]|`^1.8.0`|1.9.0|1.9.0|\\n|[`recase`]|`^4.1.0`|4.1.0|4.1.0|\\n|[`yaml`]|`^3.1.2`|3.1.2|3.1.2|\\n\\n<details><summary>Transitive dependencies</summary>\\n\\n|Package|Constraint|Compatible|Latest|\\n|:-|:-|:-|:-|\\n|[`async`]|-|2.11.0|2.11.0|\\n|[`meta`]|-|1.12.0|1.12.0|\\n|[`source_span`]|-|1.10.0|1.10.0|\\n|[`string_scanner`]|-|1.2.0|1.2.0|\\n|[`term_glyph`]|-|1.2.1|1.2.1|\\n</details>\\n\\nTo reproduce run `dart pub outdated --no-dev-dependencies --up-to-date --no-dependency-overrides`.\\n\\n[`args`]: https://pub.dev/packages/args\\n[`collection`]: https://pub.dev/packages/collection\\n[`colorize`]: https://pub.dev/packages/colorize\\n[`dart_ping`]: https://pub.dev/packages/dart_ping\\n[`path`]: https://pub.dev/packages/path\\n[`recase`]: https://pub.dev/packages/recase\\n[`yaml`]: https://pub.dev/packages/yaml\\n[`async`]: https://pub.dev/packages/async\\n[`meta`]: https://pub.dev/packages/meta\\n[`source_span`]: https://pub.dev/packages/source_span\\n[`string_scanner`]: https://pub.dev/packages/string_scanner\\n[`term_glyph`]: https://pub.dev/packages/term_glyph\\n\\n\\n### [*] 10/10 points: Package supports latest stable Dart and Flutter SDKs\\n\"\r\n      }\r\n    ]\r\n  },\r\n  \"screenshots\": [],\r\n  \"result\": {\r\n    \"repositoryUrl\": \"https://github.com/inlavigo/gg.git\",\r\n    \"issueTrackerUrl\": \"https://github.com/inlavigo/gg/issues\",\r\n    \"repository\": {\r\n      \"provider\": \"github\",\r\n      \"host\": \"github.com\",\r\n      \"repository\": \"inlavigo/gg\",\r\n      \"branch\": \"main\"\r\n    },\r\n    \"grantedPoints\": 140,\r\n    \"maxPoints\": 140\r\n  },\r\n  \"urlProblems\": [],\r\n  \"scores\": {\r\n    \"grantedPoints\": 140,\r\n    \"maxPoints\": 140\r\n  }\r\n}\r\n\n\ntest\\data\\pana_not_success_report.json:\n{\r\n  \"createdAt\": \"2024-02-24T21:04:10.004027\",\r\n  \"runtimeInfo\": {\r\n    \"panaVersion\": \"0.22.1\",\r\n    \"sdkVersion\": \"3.4.0-140.0.dev\",\r\n    \"flutterVersions\": {\r\n      \"frameworkVersion\": \"3.20.0-7.0.pre.66\",\r\n      \"channel\": \"master\",\r\n      \"repositoryUrl\": \"https://github.com/flutter/flutter.git\",\r\n      \"frameworkRevision\": \"ea3d066237a5559d54ad778283e516e74af5e596\",\r\n      \"frameworkCommitDate\": \"2024-02-15 15:37:40 -0600\",\r\n      \"engineRevision\": \"3af336bfb2dfd9080c028fadcafca39a06e20e43\",\r\n      \"dartSdkVersion\": \"3.4.0 (build 3.4.0-140.0.dev)\",\r\n      \"devToolsVersion\": \"2.33.0-dev.6\",\r\n      \"flutterVersion\": \"3.20.0-7.0.pre.66\",\r\n      \"flutterRoot\": \"/Users/gatzsche/dev/flutter\"\r\n    }\r\n  },\r\n  \"packageName\": \"gg\",\r\n  \"packageVersion\": \"1.0.0\",\r\n  \"pubspec\": {\r\n    \"name\": \"gg\",\r\n    \"description\": \"Offers pre-commit checks like analyzing, linting, tests and coverage.\",\r\n    \"version\": \"1.0.0\",\r\n    \"environment\": {\r\n      \"sdk\": \">=3.3.0<4.0.0\"\r\n    },\r\n    \"dependencies\": {\r\n      \"args\": \"^2.4.2\",\r\n      \"collection\": \"^1.18.0\",\r\n      \"colorize\": \"^3.0.0\",\r\n      \"dart_ping\": \"^9.0.1\",\r\n      \"path\": \"^1.8.0\",\r\n      \"recase\": \"^4.1.0\",\r\n      \"yaml\": \"^3.1.2\"\r\n    },\r\n    \"dev_dependencies\": {\r\n      \"lints\": \"^3.0.0\",\r\n      \"pana\": \"^0.22.1\",\r\n      \"test\": \"^1.24.0\"\r\n    }\r\n  },\r\n  \"licenseFile\": {\r\n    \"path\": \"LICENSE\",\r\n    \"name\": \"MIT\"\r\n  },\r\n  \"licenses\": [\r\n    {\r\n      \"path\": \"LICENSE\",\r\n      \"spdxIdentifier\": \"MIT\"\r\n    }\r\n  ],\r\n  \"allDependencies\": [\r\n    \"args\",\r\n    \"async\",\r\n    \"collection\",\r\n    \"colorize\",\r\n    \"dart_ping\",\r\n    \"lints\",\r\n    \"meta\",\r\n    \"pana\",\r\n    \"path\",\r\n    \"recase\",\r\n    \"source_span\",\r\n    \"string_scanner\",\r\n    \"term_glyph\",\r\n    \"test\",\r\n    \"yaml\"\r\n  ],\r\n  \"tags\": [\r\n    \"sdk:dart\",\r\n    \"sdk:flutter\",\r\n    \"platform:android\",\r\n    \"platform:ios\",\r\n    \"platform:windows\",\r\n    \"platform:linux\",\r\n    \"platform:macos\",\r\n    \"runtime:native-aot\",\r\n    \"runtime:native-jit\",\r\n    \"is:null-safe\",\r\n    \"is:dart3-compatible\",\r\n    \"license:mit\",\r\n    \"license:fsf-libre\",\r\n    \"license:osi-approved\"\r\n  ],\r\n  \"report\": {\r\n    \"sections\": [\r\n      {\r\n        \"id\": \"convention\",\r\n        \"title\": \"Follow Dart file conventions\",\r\n        \"grantedPoints\": 20,\r\n        \"maxPoints\": 30,\r\n        \"status\": \"failed\",\r\n        \"summary\": \"### [x] 0/10 points: Provide a valid `pubspec.yaml`\\n\\n* `pubspec.yaml` doesn't have a `homepage` entry.\\n* `pubspec.yaml` doesn't have a `repository` entry.\\n\\n### [*] 5/5 points: Provide a valid `README.md`\\n\\n\\n### [*] 5/5 points: Provide a valid `CHANGELOG.md`\\n\\n\\n### [*] 10/10 points: Use an OSI-approved license\\n\\nDetected license: `MIT`.\"\r\n      },\r\n      {\r\n        \"id\": \"documentation\",\r\n        \"title\": \"Provide documentation\",\r\n        \"grantedPoints\": 20,\r\n        \"maxPoints\": 20,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 10/10 points: 20% or more of the public API has dartdoc comments\\n\\n6 out of 7 API elements (85.7 %) have documentation comments.\\n\\nSome symbols that are missing documentation: `gg`.\\n\\n### [*] 10/10 points: Package has an example\\n\"\r\n      },\r\n      {\r\n        \"id\": \"platform\",\r\n        \"title\": \"Platform support\",\r\n        \"grantedPoints\": 20,\r\n        \"maxPoints\": 20,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 20/20 points: Supports 5 of 6 possible platforms (**iOS**, **Android**, Web, **Windows**, **macOS**, **Linux**)\\n\\n* ✓ Android\\n* ✓ iOS\\n* ✓ Windows\\n* ✓ Linux\\n* ✓ macOS\\n\\nThese platforms are not supported:\\n\\n<details>\\n<summary>\\nPackage not compatible with platform Web\\n</summary>\\n\\nBecause:\\n* `package:gg/gg.dart` that imports:\\n* `package:gg/src/gg.dart` that imports:\\n* `package:gg/src/tools/is_github.dart` that imports:\\n* `dart:io`\\n</details>\"\r\n      },\r\n      {\r\n        \"id\": \"analysis\",\r\n        \"title\": \"Pass static analysis\",\r\n        \"grantedPoints\": 50,\r\n        \"maxPoints\": 50,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 50/50 points: code has no errors, warnings, lints, or formatting issues\\n\"\r\n      },\r\n      {\r\n        \"id\": \"dependency\",\r\n        \"title\": \"Support up-to-date dependencies\",\r\n        \"grantedPoints\": 20,\r\n        \"maxPoints\": 20,\r\n        \"status\": \"passed\",\r\n        \"summary\": \"### [*] 10/10 points: All of the package dependencies are supported in the latest version\\n\\n|Package|Constraint|Compatible|Latest|\\n|:-|:-|:-|:-|\\n|[`args`]|`^2.4.2`|2.4.2|2.4.2|\\n|[`collection`]|`^1.18.0`|1.18.0|1.18.0|\\n|[`colorize`]|`^3.0.0`|3.0.0|3.0.0|\\n|[`dart_ping`]|`^9.0.1`|9.0.1|9.0.1|\\n|[`path`]|`^1.8.0`|1.9.0|1.9.0|\\n|[`recase`]|`^4.1.0`|4.1.0|4.1.0|\\n|[`yaml`]|`^3.1.2`|3.1.2|3.1.2|\\n\\n<details><summary>Transitive dependencies</summary>\\n\\n|Package|Constraint|Compatible|Latest|\\n|:-|:-|:-|:-|\\n|[`async`]|-|2.11.0|2.11.0|\\n|[`meta`]|-|1.12.0|1.12.0|\\n|[`source_span`]|-|1.10.0|1.10.0|\\n|[`string_scanner`]|-|1.2.0|1.2.0|\\n|[`term_glyph`]|-|1.2.1|1.2.1|\\n</details>\\n\\nTo reproduce run `dart pub outdated --no-dev-dependencies --up-to-date --no-dependency-overrides`.\\n\\n[`args`]: https://pub.dev/packages/args\\n[`collection`]: https://pub.dev/packages/collection\\n[`colorize`]: https://pub.dev/packages/colorize\\n[`dart_ping`]: https://pub.dev/packages/dart_ping\\n[`path`]: https://pub.dev/packages/path\\n[`recase`]: https://pub.dev/packages/recase\\n[`yaml`]: https://pub.dev/packages/yaml\\n[`async`]: https://pub.dev/packages/async\\n[`meta`]: https://pub.dev/packages/meta\\n[`source_span`]: https://pub.dev/packages/source_span\\n[`string_scanner`]: https://pub.dev/packages/string_scanner\\n[`term_glyph`]: https://pub.dev/packages/term_glyph\\n\\n\\n### [*] 10/10 points: Package supports latest stable Dart and Flutter SDKs\\n\"\r\n      }\r\n    ]\r\n  },\r\n  \"screenshots\": [],\r\n  \"result\": {\r\n    \"grantedPoints\": 130,\r\n    \"maxPoints\": 140\r\n  },\r\n  \"urlProblems\": [],\r\n  \"scores\": {\r\n    \"grantedPoints\": 130,\r\n    \"maxPoints\": 140\r\n  }\r\n}\r\n\n\ntest\\commands\\info_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_capture_print/gg_capture_print.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n\r\n  late CommandRunner<void> runner;\r\n  late Info info;\r\n\r\n  setUp(() {\r\n    info = Info(ggLog: ggLog);\r\n    runner = CommandRunner<void>('gg', 'gg)')..addCommand(info);\r\n  });\r\n\r\n  void expectCommand(Command<dynamic> command) {\r\n    final message = messages[0];\r\n    expect(message, contains(command.name));\r\n    expect(message, contains(command.description));\r\n  }\r\n\r\n  group('Info', () {\r\n    group('run()', () {\r\n      test('should provide various information commands', () async {\r\n        await capturePrint(\r\n          ggLog: ggLog,\r\n          code: () => runner.run(['info', '--help']),\r\n        );\r\n\r\n        expect(messages, hasLength(1));\r\n        expectCommand(info);\r\n        expectCommand(ModifiedFiles(ggLog: ggLog));\r\n        expectCommand(LastChangesHash(ggLog: ggLog));\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\do_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/src/commands/do.dart';\r\nimport 'package:gg_capture_print/gg_capture_print.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  late Do doCommand;\r\n  final messages = <String>[];\r\n  late CommandRunner<void> runner;\r\n\r\n  setUp(() {\r\n    d = Directory.systemTemp.createTempSync();\r\n    messages.clear();\r\n    doCommand = Do(ggLog: messages.add);\r\n    runner = CommandRunner<void>('test', 'test')..addCommand(doCommand);\r\n  });\r\n\r\n  tearDown(() {\r\n    d.deleteSync(recursive: true);\r\n  });\r\n\r\n  group('Do', () {\r\n    test('should work fine', () async {\r\n      await capturePrint(\r\n        code: () async {\r\n          await runner.run(['do', '--help']);\r\n        },\r\n        ggLog: messages.add,\r\n      );\r\n\r\n      expect(\r\n        messages.first,\r\n        contains('Provide actions or commit, push, publish, merge.'),\r\n      );\r\n      // our new subcommand should also show up\r\n      expect(messages.join('\\n'), contains('merge'));\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\do\\do_upgrade_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n  late CommandRunner<void> runner;\r\n  late DoUpgrade doUpgrade;\r\n\r\n  // ...........................................................................\r\n  late GgState? state;\r\n  late MockDidUpgrade didUpgrade;\r\n  late MockCanUpgrade canUpgrade;\r\n  late MockGgProcessWrapper processWrapper;\r\n  late MockCanCommit canCommit;\r\n\r\n  // ...........................................................................\r\n  void initMocks() {\r\n    registerFallbackValue(d);\r\n    state = GgState(ggLog: ggLog);\r\n    didUpgrade = MockDidUpgrade();\r\n    canUpgrade = MockCanUpgrade();\r\n    processWrapper = MockGgProcessWrapper();\r\n    canCommit = MockCanCommit();\r\n  }\r\n\r\n  // ...........................................................................\r\n  void initDoUpgrade() {\r\n    doUpgrade = DoUpgrade(\r\n      ggLog: ggLog,\r\n      state: state,\r\n      didUpgrade: didUpgrade,\r\n      canUpgrade: canUpgrade,\r\n      processWrapper: processWrapper,\r\n      canCommit: canCommit,\r\n    );\r\n\r\n    runner.addCommand(doUpgrade);\r\n  }\r\n\r\n  // ...........................................................................\r\n  void mockDartPubUpgrade({\r\n    bool majorVersions = false,\r\n    int exitCode = 0,\r\n    String stdout = '',\r\n    String stderr = '',\r\n    bool upgradingCausesChange = true,\r\n  }) {\r\n    when(\r\n      () => processWrapper.run('dart', [\r\n        'pub',\r\n        'upgrade',\r\n        if (majorVersions) '--major-versions',\r\n      ], workingDirectory: d.path),\r\n    ).thenAnswer((_) async {\r\n      if (upgradingCausesChange) {\r\n        await updateSampleFileWithoutCommitting(d);\r\n      }\r\n\r\n      return ProcessResult(0, exitCode, stdout, stderr);\r\n    });\r\n  }\r\n\r\n  // ...........................................................................\r\n  void mockCanCommit({bool success = true}) {\r\n    canCommit.mockExec(\r\n      result: null,\r\n      directory: d,\r\n      ggLog: ggLog,\r\n      doThrow: !success,\r\n      message: 'CanCommit failed.',\r\n      force: true,\r\n      saveState: null,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  void initDefaultMocks() {\r\n    didUpgrade.mockGet(\r\n      result: false,\r\n      directory: d,\r\n      ggLog: null,\r\n      majorVersions: false,\r\n    );\r\n\r\n    canUpgrade.mockExec(result: null, directory: d, ggLog: ggLog);\r\n    mockCanCommit();\r\n    mockDartPubUpgrade();\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    d = await Directory.systemTemp.createTemp();\r\n    await initGit(d);\r\n    await addAndCommitSampleFile(d);\r\n\r\n    messages.clear();\r\n    runner = CommandRunner<void>('gg', 'gg');\r\n    initMocks();\r\n    initDoUpgrade();\r\n    initDefaultMocks();\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('DoUpgrade', () {\r\n    group('- main case', () {\r\n      group('- should run »dart pub upggrade», '\r\n          'check if everything still runs (canCommit) '\r\n          'and finally commit and publish changes', () {\r\n        void check() {\r\n          expect(messages[0], contains('✅ CanUpgrade'));\r\n          expect(messages[1], contains('⌛️ Run »dart pub upgrade«'));\r\n          expect(messages[2], contains('✅ Run »dart pub upgrade«'));\r\n          expect(messages[3], contains('✅ CanCommit'));\r\n        }\r\n\r\n        test('- programmatically', () async {\r\n          await doUpgrade.exec(directory: d, ggLog: ggLog);\r\n          check();\r\n        });\r\n\r\n        test('- via CLI', () async {\r\n          await runner.run(['upgrade', '-i', d.path]);\r\n          check();\r\n        });\r\n      });\r\n    });\r\n\r\n    group('- edge cases', () {\r\n      group('- should fail', () {\r\n        group('- when preconditions for can upgrade are not met', () {\r\n          setUp(() {\r\n            // Let canUpgrade fail\r\n            canUpgrade.mockExec(\r\n              result: null,\r\n              directory: d,\r\n              doThrow: true, // <- Throws\r\n              message: 'CanUpgrade failed',\r\n            );\r\n          });\r\n\r\n          Future<void> perform(Future<void> testCode) async {\r\n            late String exception;\r\n            try {\r\n              await testCode;\r\n            } catch (e) {\r\n              exception = e.toString();\r\n            }\r\n            expect(exception, contains('CanUpgrade failed'));\r\n          }\r\n\r\n          test('- programmatically', () async {\r\n            await perform(doUpgrade.exec(directory: d, ggLog: ggLog));\r\n          });\r\n\r\n          test('- via CLI', () async {\r\n            await perform(runner.run(['upgrade', d.path, '-i', d.path]));\r\n          });\r\n        });\r\n\r\n        test('- when »dart pub upgrade« exists with an error', () async {\r\n          mockDartPubUpgrade(exitCode: 1, stderr: 'Something went wrong');\r\n\r\n          late String exception;\r\n          try {\r\n            await doUpgrade.exec(directory: d, ggLog: ggLog);\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n          expect(\r\n            exception,\r\n            contains('»dart pub upgrade« failed: Something went wrong'),\r\n          );\r\n        });\r\n      });\r\n\r\n      group('- should do nothing', () {\r\n        group('- when everything is already upgraded', () {\r\n          setUp(() {\r\n            // Let's say didUpgrade returns true\r\n            didUpgrade.mockGet(\r\n              result: true,\r\n              directory: d,\r\n              majorVersions: false,\r\n            );\r\n          });\r\n\r\n          void check() {\r\n            expect(messages.last, yellow('Everything is already up to date.'));\r\n          }\r\n\r\n          test('- programmatically', () async {\r\n            await doUpgrade.exec(directory: d, ggLog: ggLog);\r\n            check();\r\n          });\r\n\r\n          test('- via CLI', () async {\r\n            await runner.run(['upgrade', d.path, '-i', d.path]);\r\n            check();\r\n          });\r\n        });\r\n      });\r\n\r\n      group('- should not commit and publish ', () {\r\n        test('when nothing was changed by »dart pub upgrade«', () async {\r\n          mockDartPubUpgrade(upgradingCausesChange: false);\r\n          await doUpgrade.exec(directory: d, ggLog: ggLog);\r\n          final allMessages = messages.join('\\n');\r\n          expect(allMessages, isNot(contains('✅ DoCommit')));\r\n          expect(allMessages, isNot(contains('✅ DoPublish')));\r\n        });\r\n      });\r\n\r\n      test(\r\n        '- should require fixing errors happening through updating',\r\n        () async {\r\n          mockCanCommit(success: false);\r\n\r\n          late String exception;\r\n          try {\r\n            await doUpgrade.exec(directory: d, ggLog: ggLog);\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          final message = red(\r\n            'After the update tests are not running anymore. '\r\n            'Please run ${blue('»gg can commit«')} and try again.',\r\n          );\r\n\r\n          expect(exception, contains(message));\r\n        },\r\n      );\r\n\r\n      group('- should allow to upgrade major versions', () {\r\n        setUp(() {\r\n          mockDartPubUpgrade(majorVersions: true);\r\n          didUpgrade.mockGet(\r\n            result: false,\r\n            directory: d,\r\n            ggLog: null,\r\n            majorVersions: true, // <- Major versions\r\n          );\r\n        });\r\n\r\n        tearDown(() {\r\n          expect(\r\n            messages[1],\r\n            contains('⌛️ Run »dart pub upgrade --major-versions«'),\r\n          );\r\n\r\n          expect(\r\n            messages[2],\r\n            contains('✅ Run »dart pub upgrade --major-versions«'),\r\n          );\r\n        });\r\n\r\n        test('- programmatically', () async {\r\n          await doUpgrade.exec(directory: d, ggLog: ggLog, majorVersions: true);\r\n        });\r\n\r\n        test('- via CLI', () async {\r\n          await runner.run(['upgrade', '-i', d.path, '--major-versions']);\r\n        });\r\n      });\r\n\r\n      test('- should init DoUpgrade with default params', () {\r\n        expect(() => DoUpgrade(ggLog: ggLog), returnsNormally);\r\n      });\r\n    });\r\n  });\r\n\r\n  // #########################################################################\r\n  group('MockDoUpgrade', () {\r\n    group('mockExec', () {\r\n      group('should mock exec', () {\r\n        test('with ggLog', () async {\r\n          final didUpgrade = MockDoUpgrade();\r\n          didUpgrade.mockExec(\r\n            result: null,\r\n            directory: d,\r\n            ggLog: ggLog,\r\n            majorVersions: true,\r\n          );\r\n\r\n          await didUpgrade.exec(\r\n            directory: d,\r\n            ggLog: ggLog,\r\n            majorVersions: true,\r\n          );\r\n\r\n          expect(messages[0], contains('✅ DoUpgrade'));\r\n        });\r\n\r\n        test('without ggLog', () async {\r\n          final didUpgrade = MockDoUpgrade();\r\n          didUpgrade.mockExec(\r\n            result: null,\r\n            directory: d,\r\n            majorVersions: true,\r\n            ggLog: null, // <-- ggLog is null\r\n          );\r\n\r\n          await didUpgrade.exec(\r\n            directory: d,\r\n            majorVersions: true,\r\n            ggLog: (_) {},\r\n          );\r\n\r\n          expect(messages, isEmpty);\r\n        });\r\n      });\r\n    });\r\n\r\n    group('mockGet', () {\r\n      group('should mock get', () {\r\n        test('with ggLog', () async {\r\n          final didUpgrade = MockDoUpgrade();\r\n          didUpgrade.mockGet(\r\n            result: null,\r\n            directory: d,\r\n            ggLog: ggLog,\r\n            majorVersions: true,\r\n          );\r\n\r\n          await didUpgrade.get(directory: d, ggLog: ggLog, majorVersions: true);\r\n\r\n          expect(messages[0], contains('✅ DoUpgrade'));\r\n        });\r\n\r\n        test('without ggLog', () async {\r\n          final didUpgrade = MockDoUpgrade();\r\n          didUpgrade.mockGet(\r\n            result: null,\r\n            directory: d,\r\n            majorVersions: true,\r\n            ggLog: null, // <-- ggLog is null\r\n          );\r\n\r\n          await didUpgrade.get(\r\n            directory: d,\r\n            majorVersions: true,\r\n            ggLog: (_) {},\r\n          );\r\n\r\n          expect(messages, isEmpty);\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\do\\do_push_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_changelog/gg_changelog.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:path/path.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() async {\r\n  late Directory dLocal;\r\n  late Directory dRemote;\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n\r\n  late File ggJson;\r\n  late DoPush doPush;\r\n  late CanPush canPush;\r\n  late CanCommit canCommit;\r\n  late DoCommit doCommit;\r\n  late IsPushed isPushed;\r\n\r\n  // ...........................................................................\r\n  void mockCanPush(bool success) {\r\n    if (success) {\r\n      when(\r\n        () => canPush.exec(\r\n          directory: any(named: 'directory'),\r\n          ggLog: ggLog,\r\n        ),\r\n      ).thenAnswer((_) async => {});\r\n      return;\r\n    } else {\r\n      when(\r\n        () => canPush.exec(\r\n          directory: any(named: 'directory'),\r\n          ggLog: ggLog,\r\n        ),\r\n      ).thenThrow(Exception('Cannot push.'));\r\n      return;\r\n    }\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    (dLocal, dRemote) = await initLocalAndRemoteGit();\r\n\r\n    await addAndCommitPubspecFile(dLocal);\r\n    await addAndCommitSampleFile(dLocal);\r\n    await pushLocalChanges(dLocal);\r\n    registerFallbackValue(dLocal);\r\n\r\n    canPush = MockCanPush();\r\n    mockCanPush(true);\r\n    doPush = DoPush(ggLog: ggLog, canPush: canPush);\r\n    canCommit = MockCanCommit();\r\n    doCommit = DoCommit(ggLog: ggLog, canCommit: canCommit);\r\n    isPushed = IsPushed(ggLog: ggLog);\r\n    ggJson = File(join(dLocal.path, '.gg.json'));\r\n\r\n    // Init pubspec.yaml\r\n    await File(\r\n      join(dLocal.path, 'pubspec.yaml'),\r\n    ).writeAsString('version: 1.0.0\\nrepository: https://foo.com');\r\n    await commitFile(dLocal, 'pubspec.yaml');\r\n\r\n    // Init CHANGELOG.md\r\n    await File(join(dLocal.path, 'CHANGELOG.md')).writeAsString('# Changelog');\r\n    await commitFile(dLocal, 'CHANGELOG.md');\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDownAll(() async {\r\n    await dLocal.delete(recursive: true);\r\n    await dRemote.delete(recursive: true);\r\n  });\r\n\r\n  group('DoPush', () {\r\n    group('exec', () {\r\n      group('should succeed', () {\r\n        group('and not push', () {\r\n          group('when everything is already pushed', () {\r\n            test('and the hashes are correct', () async {\r\n              // Make a change that could be pushed\r\n              await updateAndCommitSampleFile(dLocal);\r\n\r\n              // Let check's pass\r\n              mockCanPush(true);\r\n\r\n              // Push the change the first time\r\n              await doPush.exec(directory: dLocal, ggLog: ggLog);\r\n              expect(\r\n                messages.last,\r\n                yellow('Checks successful. Pushed successful.'),\r\n              );\r\n              expect(\r\n                await isPushed.get(directory: dLocal, ggLog: ggLog),\r\n                isTrue,\r\n              );\r\n\r\n              // Execute the same push a second time\r\n              await doPush.exec(directory: dLocal, ggLog: ggLog);\r\n              expect(messages.last, yellow('Already checked and pushed.'));\r\n            });\r\n          });\r\n        });\r\n\r\n        group('and push', () {\r\n          test('and create an upstream branch, when not existing', () async {\r\n            // Create a branch that does not exist on the remote\r\n            const branchName = 'new-branch';\r\n            await createBranch(dLocal, branchName);\r\n\r\n            // Before the upstream branch should not exist\r\n            final upstreamBranchBefore = await upstreamBranchName(dLocal);\r\n            expect(upstreamBranchBefore, isEmpty);\r\n\r\n            // Create a change\r\n            await updateSampleFileWithoutCommitting(dLocal);\r\n\r\n            // Commit the change using ggDoCommit\r\n            when(\r\n              () => canCommit.exec(directory: dLocal, ggLog: ggLog),\r\n            ).thenAnswer((_) async => {});\r\n            await doCommit.exec(\r\n              directory: dLocal,\r\n              ggLog: ggLog,\r\n              message: 'Message 0',\r\n              logType: LogType.added,\r\n            );\r\n\r\n            // Push the change using ggDoPush\r\n            await doPush.exec(directory: dLocal, ggLog: ggLog);\r\n\r\n            // The changes should be pushed\r\n            expect(await isPushed.get(directory: dLocal, ggLog: ggLog), isTrue);\r\n\r\n            // The upstream branch should be set\r\n            final upstreamBranchAfter = await upstreamBranchName(dLocal);\r\n            expect(upstreamBranchAfter, 'origin/$branchName');\r\n          });\r\n          group('and overwrite the last pushed commit', () {\r\n            test('when force or --force is specified', () async {\r\n              // Make git push succeed\r\n              final processWrapper = MockGgProcessWrapper();\r\n\r\n              when(\r\n                () => processWrapper.run('git', [\r\n                  'push',\r\n                  '-f',\r\n                ], workingDirectory: dLocal.path),\r\n              ).thenAnswer((_) async => ProcessResult(1, 0, '', ''));\r\n\r\n              // Make a change that could be pushed\r\n              await updateAndCommitSampleFile(dLocal);\r\n\r\n              // Let check's pass\r\n              mockCanPush(true);\r\n\r\n              // Create the command\r\n              final doPush = DoPush(\r\n                ggLog: ggLog,\r\n                canPush: canPush,\r\n                processWrapper: processWrapper,\r\n              );\r\n\r\n              // Create a command runner\r\n              final runner = CommandRunner<void>('test', 'test');\r\n              runner.addCommand(doPush);\r\n\r\n              // Execute the command\r\n              await runner.run(['push', '--input', dLocal.path, '--force']);\r\n\r\n              // Make sure the force flag is passed to git\r\n              verify(\r\n                () => processWrapper.run('git', [\r\n                  'push',\r\n                  '-f',\r\n                ], workingDirectory: dLocal.path),\r\n              ).called(1);\r\n            });\r\n          });\r\n\r\n          group('a new hash', () {\r\n            test('when before was not pushed with »gg do push«', () async {\r\n              // Create a change\r\n              await updateSampleFileWithoutCommitting(dLocal);\r\n\r\n              // Commit the change using ggDoCommit\r\n              when(\r\n                () => canCommit.exec(directory: dLocal, ggLog: ggLog),\r\n              ).thenAnswer((_) async => {});\r\n              await doCommit.exec(\r\n                directory: dLocal,\r\n                ggLog: ggLog,\r\n                message: 'Message 0',\r\n                logType: LogType.added,\r\n              );\r\n\r\n              // Push the change without ggDoPush\r\n              await pushLocalChanges(dLocal);\r\n              expect(\r\n                await isPushed.get(directory: dLocal, ggLog: ggLog),\r\n                isTrue,\r\n              );\r\n\r\n              // Run ggDoPush should update .gg.json\r\n              final ggJsonBefore = await ggJson.readAsString();\r\n              await doPush.exec(directory: dLocal, ggLog: ggLog);\r\n              final ggJsonAfter = await ggJson.readAsString();\r\n              expect(ggJsonBefore, isNot(ggJsonAfter));\r\n\r\n              // The new gg.json should be pushed\r\n              expect(\r\n                await isPushed.get(directory: dLocal, ggLog: ggLog),\r\n                isTrue,\r\n              );\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      group('should throw', () {\r\n        test('when canPush throws', () async {\r\n          // Make a change that could be pushed\r\n          await updateAndCommitSampleFile(dLocal);\r\n\r\n          // Let canPush fail\r\n          mockCanPush(false);\r\n\r\n          // Execute doPoush -> should fail\r\n          late String exception;\r\n          try {\r\n            await doPush.exec(directory: dLocal, ggLog: ggLog);\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          expect(exception, 'Exception: Cannot push.');\r\n        });\r\n\r\n        test('when »git push« throws', () async {\r\n          // Make git fail\r\n          final processWrapper = MockGgProcessWrapper();\r\n\r\n          when(\r\n            () => processWrapper.run('git', [\r\n              'push',\r\n            ], workingDirectory: dLocal.path),\r\n          ).thenAnswer((_) async => ProcessResult(1, 1, '', 'Some error'));\r\n\r\n          // Let check's pass\r\n          mockCanPush(true);\r\n\r\n          // Make a change that could be pushed\r\n          await updateAndCommitSampleFile(dLocal);\r\n\r\n          // Create the command\r\n          final doPush = DoPush(\r\n            ggLog: ggLog,\r\n            canPush: canPush,\r\n            processWrapper: processWrapper,\r\n          );\r\n\r\n          // Execute the command\r\n          late String exception;\r\n          try {\r\n            await doPush.exec(directory: dLocal, ggLog: ggLog);\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          expect(exception, 'Exception: git push failed: Some error');\r\n        });\r\n\r\n        test('when creating an upstream branch fails', () async {\r\n          // Create a branch that does not exist on the remote\r\n          const branchName = 'new-branch';\r\n          await createBranch(dLocal, branchName);\r\n\r\n          // Make git push fail\r\n          final processWrapper = MockGgProcessWrapper();\r\n\r\n          when(\r\n            () => processWrapper.run('git', [\r\n              'push',\r\n              '--set-upstream',\r\n              'origin',\r\n              branchName,\r\n            ], workingDirectory: dLocal.path),\r\n          ).thenAnswer((_) async => ProcessResult(1, 1, '', 'Some error'));\r\n\r\n          // Create the command\r\n          final doPush = DoPush(\r\n            ggLog: ggLog,\r\n            canPush: canPush,\r\n            processWrapper: processWrapper,\r\n          );\r\n\r\n          // Execute the command\r\n          late String exception;\r\n          try {\r\n            await doPush.exec(directory: dLocal, ggLog: ggLog);\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          expect(\r\n            exception,\r\n            'Exception: git push --set-upstream origin $branchName failed: '\r\n            'Some error',\r\n          );\r\n        });\r\n      });\r\n    });\r\n\r\n    test('should have a code coverage of 100%', () {\r\n      DoPush(ggLog: ggLog);\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\do\\do_publish_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_direct_json/gg_direct_json.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:path/path.dart';\r\nimport 'package:pub_semver/pub_semver.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n  late Directory d;\r\n  late Directory dRemote;\r\n  late Directory Function() dMock;\r\n  late DoPublish doPublish;\r\n  late CanPublish canPublish;\r\n  late PublishedVersion publishedVersion;\r\n  late IsVersionPrepared isVersionPrepared;\r\n\r\n  late int successHash;\r\n  late int needsChangeHash;\r\n  late Version publishedVersionValue;\r\n\r\n  // ...........................................................................\r\n  // Mocks\r\n  late Publish publish;\r\n\r\n  void mockPublishIsSuccessful({\r\n    required bool success,\r\n    required bool askBeforePublishing,\r\n  }) =>\r\n      when(\r\n        () => publish.exec(\r\n          directory: dMock(),\r\n          ggLog: ggLog,\r\n          askBeforePublishing: askBeforePublishing,\r\n        ),\r\n      ).thenAnswer((_) async {\r\n        if (!success) {\r\n          throw Exception('Publishing failed.');\r\n        } else {\r\n          publishedVersionValue = Version.parse('1.2.4');\r\n          ggLog('Publishing was successful.');\r\n        }\r\n      });\r\n\r\n  void mockPublishedVersion() =>\r\n      when(\r\n        () => publishedVersion.get(\r\n          directory: dMock(),\r\n          ggLog: any(named: 'ggLog'),\r\n        ),\r\n      ).thenAnswer((_) async {\r\n        return publishedVersionValue;\r\n      });\r\n\r\n  // ...........................................................................\r\n  Future<void> makeLastStateSuccessful() async {\r\n    successHash = await LastChangesHash(\r\n      ggLog: ggLog,\r\n    ).get(directory: d, ggLog: ggLog, ignoreFiles: GgState.ignoreFiles);\r\n\r\n    await File(join(d.path, '.gg.json')).writeAsString(\r\n      '{\"canCommit\":{\"success\":{\"hash\":$successHash}},'\r\n      '\"doCommit\":{\"success\":{\"hash\":$successHash}},'\r\n      '\"canPush\":{\"success\":{\"hash\":$successHash}},'\r\n      '\"doPush\":{\"success\":{\"hash\":$successHash}},'\r\n      '\"canPublish\":{\"success\":{\"hash\":$successHash}},'\r\n      '\"doPublish\":{\"success\":{\"hash\":$successHash}}}',\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    // Create repositories\r\n    d = await Directory.systemTemp.createTemp('local');\r\n    await initLocalGit(d);\r\n    dRemote = await Directory.systemTemp.createTemp('remote');\r\n    await initRemoteGit(dRemote);\r\n    await addRemoteToLocal(local: d, remote: dRemote);\r\n    publishedVersionValue = Version.parse('1.2.3');\r\n\r\n    // Clear messagesa\r\n    messages.clear();\r\n\r\n    // Setup a pubspec.yaml and a CHANGELOG.md with right versions\r\n    await File(join(d.path, 'pubspec.yaml')).writeAsString(\r\n      'name: gg\\n\\nversion: 1.2.4\\n'\r\n      'repository: https://github.com/inlavigo/gg.git',\r\n    );\r\n\r\n    // Prepare ChangeLog\r\n    await File(join(d.path, 'CHANGELOG.md')).writeAsString(\r\n      '# Changelog\\n\\n'\r\n      '## Unreleased\\n'\r\n      '-Message 1\\n'\r\n      '-Message 2\\n'\r\n      '## 1.2.3 - 2024-04-05\\n\\n- First version',\r\n    );\r\n\r\n    // Create a .gg.json that has all preconditions for publishing\r\n    needsChangeHash = 12345;\r\n\r\n    // Mock publishing\r\n    dMock = () => any(\r\n      named: 'directory',\r\n      that: predicate<Directory>((x) => x.path == d.path),\r\n    );\r\n    registerFallbackValue(d);\r\n    publish = MockPublish();\r\n\r\n    publishedVersion = MockPublishedVersion();\r\n\r\n    isVersionPrepared = IsVersionPrepared(\r\n      ggLog: ggLog,\r\n      publishedVersion: publishedVersion,\r\n    );\r\n\r\n    canPublish = CanPublish(ggLog: ggLog, isVersionPrepared: isVersionPrepared);\r\n    mockPublishedVersion();\r\n\r\n    // Instantiate with mocks\r\n    doPublish = DoPublish(\r\n      ggLog: ggLog,\r\n      publish: publish,\r\n      prepareNextVersion: PrepareNextVersion(\r\n        ggLog: ggLog,\r\n        publishedVersion: publishedVersion,\r\n      ),\r\n      canPublish: canPublish,\r\n      isPublished: IsPublished(\r\n        ggLog: ggLog,\r\n        publishedVersion: publishedVersion,\r\n      ),\r\n    );\r\n\r\n    await makeLastStateSuccessful();\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n    await dRemote.delete(recursive: true);\r\n  });\r\n\r\n  group('DoPublish', () {\r\n    group('exec(directory)', () {\r\n      group('should succeed', () {\r\n        group('and not publish', () {\r\n          test('when publishing was already successful', () async {\r\n            await DirectJson.writeFile(\r\n              file: File(join(d.path, '.gg.json')),\r\n              path: 'doPublish/success/hash',\r\n              value: successHash,\r\n            );\r\n\r\n            await doPublish.exec(directory: d, ggLog: ggLog);\r\n            expect(messages[0], yellow('Current state is already published.'));\r\n          });\r\n        });\r\n        group('and publish', () {\r\n          group('to pub.dev', () {\r\n            group('when no »publish_to: none« is found in pubspec.yaml', () {\r\n              group('when the package', () {\r\n                group('has been published before', () {\r\n                  group('and ask for confirmation', () {\r\n                    for (final ask in [true, null]) {\r\n                      test('when askBeforePublishing is $ask', () async {\r\n                        // Expect asking for confirmation\r\n                        mockPublishIsSuccessful(\r\n                          success: true,\r\n                          askBeforePublishing: true,\r\n                        );\r\n\r\n                        // Mock needing publish\r\n                        await DirectJson.writeFile(\r\n                          file: File(join(d.path, '.gg.json')),\r\n                          path: 'doPublish/success/hash',\r\n                          value: needsChangeHash,\r\n                        );\r\n\r\n                        // Publish\r\n                        await doPublish.exec(\r\n                          directory: d,\r\n                          ggLog: ggLog,\r\n                          askBeforePublishing: ask,\r\n                        );\r\n\r\n                        // Were the steps performed?\r\n                        var i = 0;\r\n                        expect(messages[i++], contains('Can publish?'));\r\n                        expect(\r\n                          messages[i++],\r\n                          contains('✅ Everything is fine.'),\r\n                        );\r\n                        expect(\r\n                          messages[i++],\r\n                          contains('Publishing was successful.'),\r\n                        );\r\n                        expect(messages[i++], contains('✅ Tag 1.2.4 added.'));\r\n                        expect(messages[i++], contains('⌛️ Increase version'));\r\n                        expect(messages[i++], contains('✅ Increase version'));\r\n\r\n                        // Was a new version created?\r\n                        final pubspec = await File(\r\n                          join(d.path, 'pubspec.yaml'),\r\n                        ).readAsString();\r\n                        final changeLog = await File(\r\n                          join(d.path, 'CHANGELOG.md'),\r\n                        ).readAsString();\r\n                        expect(pubspec, contains('version: 1.2.5'));\r\n                        expect(changeLog, contains('## [1.2.4] -'));\r\n\r\n                        // Was the new version checked in?\r\n                        final headMessage = await HeadMessage(\r\n                          ggLog: ggLog,\r\n                        ).get(directory: d, ggLog: ggLog);\r\n                        expect(\r\n                          headMessage,\r\n                          'Prepare development of version 1.2.5',\r\n                        );\r\n\r\n                        // Was .gg.json updated in a way that didCommit,\r\n                        // didPush and didPublish return true?\r\n                        expect(\r\n                          await DidCommit(\r\n                            ggLog: ggLog,\r\n                          ).get(directory: d, ggLog: ggLog),\r\n                          isTrue,\r\n                        );\r\n\r\n                        expect(\r\n                          await DidPush(\r\n                            ggLog: ggLog,\r\n                          ).get(directory: d, ggLog: ggLog),\r\n                          isTrue,\r\n                        );\r\n\r\n                        expect(\r\n                          await DidPublish(\r\n                            ggLog: ggLog,\r\n                          ).get(directory: d, ggLog: ggLog),\r\n                          isTrue,\r\n                        );\r\n                      });\r\n                    }\r\n                  });\r\n\r\n                  group('has not been published before', () {\r\n                    test('and askForConfirmation is true', () async {\r\n                      /// Mock that the package was never published before\r\n                      publishedVersionValue = Version(0, 0, 0);\r\n                      mockPublishedVersion();\r\n\r\n                      // Expect asking for confirmation\r\n                      mockPublishIsSuccessful(\r\n                        success: true,\r\n                        askBeforePublishing: true,\r\n                      );\r\n\r\n                      // Mock needing publish\r\n                      await DirectJson.writeFile(\r\n                        file: File(join(d.path, '.gg.json')),\r\n                        path: 'doPublish/success/hash',\r\n                        value: needsChangeHash,\r\n                      );\r\n\r\n                      // Publish\r\n                      await doPublish.exec(\r\n                        directory: d,\r\n                        ggLog: ggLog,\r\n                        askBeforePublishing: true,\r\n                      );\r\n\r\n                      // Check\r\n                      expect(\r\n                        await DidPublish(\r\n                          ggLog: ggLog,\r\n                        ).get(directory: d, ggLog: ggLog),\r\n                        isTrue,\r\n                      );\r\n                    });\r\n                  });\r\n                });\r\n              });\r\n\r\n              group('without asking for confirmation', () {\r\n                test('when askBeforePublishing is false', () async {\r\n                  // Expect not asking for confirmation\r\n                  mockPublishIsSuccessful(\r\n                    success: true,\r\n                    askBeforePublishing: false,\r\n                  );\r\n\r\n                  // Mock needing publish\r\n                  await DirectJson.writeFile(\r\n                    file: File(join(d.path, '.gg.json')),\r\n                    path: 'doPublish/success/hash',\r\n                    value: needsChangeHash,\r\n                  );\r\n\r\n                  // Publish\r\n                  await doPublish.exec(\r\n                    directory: d,\r\n                    ggLog: ggLog,\r\n                    askBeforePublishing: false,\r\n                  );\r\n\r\n                  // Check result\r\n                  expect(\r\n                    await DidPublish(\r\n                      ggLog: ggLog,\r\n                    ).get(directory: d, ggLog: ggLog),\r\n                    isTrue,\r\n                  );\r\n                });\r\n              });\r\n            });\r\n          });\r\n\r\n          group('not to pub.dev', () {\r\n            test('when »publish_to: none« is found in pubspec.yaml', () async {\r\n              doPublish = DoPublish(ggLog: ggLog, publish: publish);\r\n\r\n              // Prepare pubspec.yaml\r\n              final pubspecFile = File(join(d.path, 'pubspec.yaml'));\r\n              const nextVersion = '1.0.1';\r\n              const currentVersion = '1.0.0';\r\n              await addAndCommitVersions(\r\n                d,\r\n                pubspec: nextVersion,\r\n                changeLog: 'Unreleased',\r\n                gitHead: currentVersion,\r\n                appendToPubspec: '\\npublish_to: none', // No publish to pub.dev\r\n              );\r\n              var pubspec = await pubspecFile.readAsString();\r\n              expect(pubspec, contains('version: 1.0.1'));\r\n\r\n              await makeLastStateSuccessful();\r\n\r\n              // Mock needing publish\r\n              await DirectJson.writeFile(\r\n                file: File(join(d.path, '.gg.json')),\r\n                path: 'doPublish/success/hash',\r\n                value: needsChangeHash,\r\n              );\r\n\r\n              // Publish\r\n              await doPublish.exec(directory: d, ggLog: ggLog);\r\n\r\n              // Were the steps performed?\r\n              var i = 0;\r\n              expect(messages[i++], contains('Can publish?'));\r\n              expect(messages[i++], contains('✅ Everything is fine.'));\r\n              expect(messages[i++], contains('Tag 1.0.1 added.'));\r\n              expect(messages[i++], contains('⌛️ Increase version'));\r\n              expect(messages[i++], contains('✅ Increase version'));\r\n\r\n              // Was a new version created?\r\n              pubspec = await pubspecFile.readAsString();\r\n              final changeLog = await File(\r\n                join(d.path, 'CHANGELOG.md'),\r\n              ).readAsString();\r\n              expect(pubspec, contains('version: 1.0.2'));\r\n              expect(changeLog, contains('## [1.0.1] -'));\r\n\r\n              // Was the new version checked in?\r\n              final headMessage = await HeadMessage(\r\n                ggLog: ggLog,\r\n              ).get(directory: d, ggLog: ggLog);\r\n              expect(headMessage, 'Prepare development of version 1.0.2');\r\n\r\n              // Was .gg.json updated in a way that didCommit,\r\n              // didPush and didPublish return true?\r\n              expect(\r\n                await DidCommit(ggLog: ggLog).get(directory: d, ggLog: ggLog),\r\n                isTrue,\r\n              );\r\n\r\n              expect(\r\n                await DidPush(ggLog: ggLog).get(directory: d, ggLog: ggLog),\r\n                isTrue,\r\n              );\r\n\r\n              expect(\r\n                await DidPublish(ggLog: ggLog).get(directory: d, ggLog: ggLog),\r\n                isTrue,\r\n              );\r\n            });\r\n          });\r\n        });\r\n      });\r\n\r\n      group('and throw', () {\r\n        group('when the package is published the first time', () {\r\n          group('has not been published before', () {\r\n            test('and askForConfirmation is false', () async {\r\n              /// Mock that the package was never published before\r\n              publishedVersionValue = Version(0, 0, 0);\r\n              mockPublishedVersion();\r\n\r\n              // Mock needing publish\r\n              await DirectJson.writeFile(\r\n                file: File(join(d.path, '.gg.json')),\r\n                path: 'doPublish/success/hash',\r\n                value: needsChangeHash,\r\n              );\r\n\r\n              // Publish with askBeforePublishing = false\r\n              late String exception;\r\n\r\n              try {\r\n                await doPublish.exec(\r\n                  directory: d,\r\n                  ggLog: ggLog,\r\n                  askBeforePublishing: false,\r\n                );\r\n              } catch (e) {\r\n                exception = e.toString();\r\n              }\r\n\r\n              // Should throw\r\n              expect(\r\n                exception,\r\n                contains(\r\n                  'Please call »gg do push« with »--ask-before-publishing«',\r\n                ),\r\n              );\r\n\r\n              // Check\r\n              expect(\r\n                await DidPublish(ggLog: ggLog).get(directory: d, ggLog: ggLog),\r\n                isFalse,\r\n              );\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    test('should have a code coverage of 100%', () {\r\n      expect(DoPublish(ggLog: ggLog), isNotNull);\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\do\\do_merge_test.dart:\n// @license\n// Copyright (c) 2025 Göran Hegenberg. All Rights Reserved.\n//\n// Use of this source code is governed by terms that can be\n// found in the LICENSE file in the root of this package.\n\nimport 'dart:io';\nimport 'package:gg/gg.dart';\nimport 'package:gg_git/gg_git_test_helpers.dart';\nimport 'package:gg_merge/gg_merge.dart' as gg_merge;\nimport 'package:mocktail/mocktail.dart';\nimport 'package:test/test.dart';\n\nvoid main() {\n  late Directory d;\n  late MockCanMerge canMerge;\n  late gg_merge.MockDoMerge merge;\n  late DoMerge doMerge;\n  final messages = <String>[];\n  final ggLog = messages.add;\n\n  setUp(() async {\n    d = await Directory.systemTemp.createTemp('do_merge');\n    await initGit(d); // Ensure d is a git repo\n    registerFallbackValue(d);\n    canMerge = MockCanMerge();\n    merge = gg_merge.MockDoMerge();\n    when(() => canMerge.exec(directory: d, ggLog: ggLog)).thenAnswer((_) async {\n      messages.add('check allowed');\n      return;\n    });\n    when(\n      () => merge.get(directory: d, ggLog: ggLog, automerge: false),\n    ).thenAnswer((_) async {\n      messages.add('do merge!');\n      messages.add('✅ Merge operation successfully started.');\n      return true;\n    });\n\n    doMerge = DoMerge(ggLog: ggLog, canMerge: canMerge, doMerge: merge);\n    messages.clear();\n  });\n\n  tearDown(() async {\n    await d.delete(recursive: true);\n  });\n\n  group('DoMerge', () {\n    test('should call canMerge and then doMerge', () async {\n      await doMerge.exec(directory: d, ggLog: ggLog);\n      expect(messages, contains('check allowed'));\n      expect(messages, contains('do merge!'));\n      expect(\n        messages.any(\n          (m) => m.contains('✅ Merge operation successfully started.'),\n        ),\n        isTrue,\n      );\n    });\n\n    test('should propagate errors from canMerge', () async {\n      when(\n        () => canMerge.exec(directory: d, ggLog: ggLog),\n      ).thenThrow(Exception('not allowed'));\n      late String error;\n      try {\n        await doMerge.exec(directory: d, ggLog: ggLog);\n      } catch (e) {\n        error = e.toString();\n      }\n      expect(error, contains('not allowed'));\n    });\n\n    test('should delegate automerge flag to _doMerge', () async {\n      when(\n        () => merge.get(directory: d, ggLog: ggLog, automerge: true),\n      ).thenAnswer((_) async {\n        messages.add('do automerge merge!');\n        return true;\n      });\n      // Ensure git repo before use:\n      await initGit(d);\n      await doMerge.get(directory: d, ggLog: ggLog, automerge: true);\n      expect(messages, contains('do automerge merge!'));\n    });\n\n    test('default constructor uses correct name and description', () {\n      final doMerge = DoMerge(ggLog: ggLog);\n      expect(doMerge.name, 'merge');\n      expect(\n        doMerge.description,\n        'Checks and performs merge/Pull-Request to main.',\n      );\n    });\n  });\n}\n\n\ntest\\commands\\do\\do_maintain_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n  late CommandRunner<void> runner;\r\n  late DoMaintain doMaintain;\r\n\r\n  late MockDoUpgrade doUpgrade;\r\n  late MockDidPublish didPublish;\r\n\r\n  // ...........................................................................\r\n  void mockDoUpgrade({required bool success, bool majorVersions = false}) {\r\n    doUpgrade.mockGet(\r\n      result: null,\r\n      doThrow: !success,\r\n      directory: d,\r\n      majorVersions: majorVersions,\r\n      ggLog: null,\r\n    );\r\n  }\r\n\r\n  void mockDidPublish({required bool success}) {\r\n    didPublish.mockExec(\r\n      result: success,\r\n      directory: d,\r\n      ggLog: ggLog,\r\n      doThrow: !success,\r\n    );\r\n  }\r\n\r\n  // ...........................................................................\r\n  void initMocks() {\r\n    doUpgrade = MockDoUpgrade();\r\n    mockDoUpgrade(success: true);\r\n\r\n    didPublish = MockDidPublish();\r\n    mockDidPublish(success: true);\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    d = await Directory.systemTemp.createTemp();\r\n    registerFallbackValue(d);\r\n\r\n    initMocks();\r\n\r\n    doMaintain = DoMaintain(\r\n      ggLog: ggLog,\r\n      doUpgrade: doUpgrade,\r\n      didPublish: didPublish,\r\n    );\r\n\r\n    runner = CommandRunner<void>('gg', 'gg')..addCommand(doMaintain);\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('DoMaintain', () {\r\n    group('- main case', () {\r\n      group('- should upgrade dependencies and check if published', () {\r\n        group('- should upgrade dependencies and check if published', () {\r\n          tearDown(() {\r\n            expect(messages[0], contains('⌛️ Upgrading dependencies'));\r\n            expect(messages[1], contains('✅ Upgrading dependencies'));\r\n            expect(messages[2], contains('✅ DidPublish'));\r\n          });\r\n\r\n          test('- programmatically', () async {\r\n            await doMaintain.exec(directory: d, ggLog: ggLog);\r\n          });\r\n          test('- via CLI', () async {\r\n            await runner.run(['maintain', '-i', d.path]);\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    group('- edge cases', () {\r\n      test('- should init with defaults', () {\r\n        final doMaintain = DoMaintain(ggLog: ggLog);\r\n\r\n        expect(doMaintain.name, 'maintain');\r\n        expect(\r\n          doMaintain.description,\r\n          'Is the package upgraded and published?',\r\n        );\r\n      });\r\n\r\n      test('- should throw on upgrade failure', () async {\r\n        mockDoUpgrade(success: false);\r\n\r\n        expect(\r\n          () => doMaintain.exec(directory: d, ggLog: ggLog),\r\n          throwsA(isA<Exception>()),\r\n        );\r\n      });\r\n\r\n      test('- should throw on publish failure', () async {\r\n        mockDidPublish(success: false);\r\n\r\n        expect(\r\n          () => doMaintain.exec(directory: d, ggLog: ggLog),\r\n          throwsA(isA<Exception>()),\r\n        );\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\do\\do_commit_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/src/commands/can/can_commit.dart';\r\nimport 'package:gg/src/commands/do/do_commit.dart';\r\nimport 'package:gg_changelog/gg_changelog.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  late DoCommit doCommit;\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n  late CommandRunner<void> runner;\r\n\r\n  late CanCommit canCommit;\r\n\r\n  // ...........................................................................\r\n  void mockCanCommit() {\r\n    registerFallbackValue(d);\r\n\r\n    when(\r\n      () => canCommit.exec(\r\n        directory: any(named: 'directory'),\r\n        ggLog: ggLog,\r\n        force: null,\r\n      ),\r\n    ).thenAnswer((_) => Future.value());\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    messages.clear();\r\n    d = await Directory.systemTemp.createTemp();\r\n    await initGit(d);\r\n    await addAndCommitSampleFile(d);\r\n\r\n    // Insert CHANGELOG.md\r\n    await addAndCommitSampleFile(\r\n      d,\r\n      fileName: 'CHANGELOG.md',\r\n      content: '# Changelog',\r\n    );\r\n\r\n    // Insert pubspec.yaml\r\n    await addAndCommitSampleFile(\r\n      d,\r\n      fileName: 'pubspec.yaml',\r\n      content:\r\n          'version: 1.0.0\\n'\r\n          'repository:https://github.com/inlavigo/gg.git',\r\n    );\r\n\r\n    // Mock stuff\r\n    canCommit = MockCanCommit();\r\n    mockCanCommit();\r\n\r\n    // Create command\r\n    doCommit = DoCommit(ggLog: ggLog, canCommit: canCommit);\r\n\r\n    // Create runner\r\n    runner = CommandRunner<void>('test', 'test');\r\n    runner.addCommand(doCommit);\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  group('DoCommit', () {\r\n    group('exec(directory, ggLog, message)', () {\r\n      group('should succeed', () {\r\n        group('and log »Already checked and committed.«', () {\r\n          test('when the command is executed the second time', () async {\r\n            // Execute command the first time\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My commit',\r\n              logType: LogType.added,\r\n            );\r\n\r\n            // Execute command the second time\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My commit 2',\r\n              logType: LogType.added,\r\n            );\r\n\r\n            expect(messages.last, yellow('Already checked and committed.'));\r\n          });\r\n        });\r\n\r\n        group('and log »Checks successful. Nothing to commit.«', () {\r\n          test('when the command is executed the first time '\r\n              'but nothing needs to be committed.', () async {\r\n            // Execute command the first time\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My commit',\r\n              logType: LogType.added,\r\n            );\r\n\r\n            expect(\r\n              messages.last,\r\n              yellow('Checks successful. Nothing to commit.'),\r\n            );\r\n          });\r\n        });\r\n\r\n        group('and commit and log »Checks successful. Commit successful.«', () {\r\n          test('when the command is executed the first time '\r\n              'and uncommitted changes were committed.', () async {\r\n            // Add uncommitted file\r\n            await addFileWithoutCommitting(d);\r\n\r\n            // Execute command the first time\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My commit',\r\n              logType: LogType.added,\r\n            );\r\n\r\n            expect(\r\n              messages.last,\r\n              yellow('Checks successful. Commit successful.'),\r\n            );\r\n          });\r\n        });\r\n\r\n        group('and update CHANGELOG.md', () {\r\n          group('when »updateChangeLog«', () {\r\n            group('is not specified', () {\r\n              test('programmatically', () async {\r\n                // Add uncommitted file\r\n                await addFileWithoutCommitting(d);\r\n\r\n                // Execute command\r\n                await doCommit.exec(\r\n                  directory: d,\r\n                  ggLog: ggLog,\r\n                  message: 'My very special commit message',\r\n                  logType: LogType.added,\r\n                );\r\n\r\n                // Check CHANGELOG.md\r\n                final changelog = await File(\r\n                  '${d.path}/CHANGELOG.md',\r\n                ).readAsString();\r\n                expect(changelog, contains('# Changelog\\n'));\r\n                expect(changelog, contains('## Unreleased\\n'));\r\n                expect(changelog, contains('## Added\\n'));\r\n                expect(changelog, contains('My very special commit message\\n'));\r\n              });\r\n\r\n              test('via CLI', () async {\r\n                // Add uncommitted file\r\n                await addFileWithoutCommitting(d);\r\n\r\n                // Execute command\r\n                await runner.run([\r\n                  'commit',\r\n                  '-i',\r\n                  d.path,\r\n                  '-m',\r\n                  'add My very special commit message',\r\n                ]);\r\n\r\n                // Check CHANGELOG.md\r\n                final changelog = await File(\r\n                  '${d.path}/CHANGELOG.md',\r\n                ).readAsString();\r\n                expect(changelog, contains('# Changelog\\n'));\r\n                expect(changelog, contains('## Unreleased\\n'));\r\n                expect(changelog, contains('## Added\\n'));\r\n                expect(changelog, contains('My very special commit message\\n'));\r\n              });\r\n            });\r\n            test('is true', () async {\r\n              // Add uncommitted file\r\n              await addFileWithoutCommitting(d);\r\n\r\n              // Execute command the first time\r\n              await doCommit.exec(\r\n                directory: d,\r\n                ggLog: ggLog,\r\n                message: 'My very special commit message',\r\n                logType: LogType.added,\r\n                updateChangeLog: true,\r\n              );\r\n\r\n              // Check CHANGELOG.md\r\n              final changelog = await File(\r\n                '${d.path}/CHANGELOG.md',\r\n              ).readAsString();\r\n              expect(changelog, contains('# Changelog\\n'));\r\n              expect(changelog, contains('## Unreleased\\n'));\r\n              expect(changelog, contains('## Added\\n'));\r\n              expect(changelog, contains('My very special commit message\\n'));\r\n            });\r\n          });\r\n        });\r\n\r\n        group('and not update CHANGELOG.md', () {\r\n          test('when »updateChangeLog« is false', () async {\r\n            // Add uncommitted file\r\n            await addFileWithoutCommitting(d);\r\n\r\n            // Check CHANGELOG.md before\r\n            final changelogFile = File('${d.path}/CHANGELOG.md');\r\n            final changeLogBefore = await changelogFile.readAsString();\r\n\r\n            // ..........................................\r\n            // Execute command with updateCHangeLog false\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My very special commit message',\r\n              logType: LogType.added,\r\n              updateChangeLog: false,\r\n            );\r\n\r\n            // Check CHANGELOG.md should not have changed\r\n            final changeLogAfter = await changelogFile.readAsString();\r\n            expect(changeLogBefore, changeLogAfter);\r\n\r\n            // ..........................................\r\n            // Execute command with updateCHangeLog true\r\n            await updateAndCommitSampleFile(d);\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My very special commit message',\r\n              logType: LogType.added,\r\n              updateChangeLog: true,\r\n            );\r\n\r\n            // CHANGELOG.md should have changed\r\n            final changeLogAfter1 = await changelogFile.readAsString();\r\n            expect(changeLogAfter1, isNot(changeLogBefore));\r\n          });\r\n\r\n          test('when command is executed with --no-log option', () async {\r\n            // Add uncommitted file\r\n            await addFileWithoutCommitting(d);\r\n\r\n            // Check CHANGELOG.md before\r\n            final changelogFile = File('${d.path}/CHANGELOG.md');\r\n            final changeLogBefore = await changelogFile.readAsString();\r\n\r\n            // ....................................\r\n            // Execute command with --no-log option\r\n            await runner.run([\r\n              'commit',\r\n              '-i',\r\n              d.path,\r\n              'add',\r\n              '-m',\r\n              'My commit',\r\n              '--no-log',\r\n            ]);\r\n\r\n            // Check CHANGELOG.md should not have changed\r\n            final changeLogAfter = await changelogFile.readAsString();\r\n            expect(changeLogBefore, changeLogAfter);\r\n\r\n            // ..........................................\r\n            // Execute command with --log option\r\n            await updateAndCommitSampleFile(d);\r\n            await runner.run([\r\n              'commit',\r\n              '-i',\r\n              d.path,\r\n              'add',\r\n              '-m',\r\n              'My commit',\r\n              '--log',\r\n            ]);\r\n\r\n            // CHANGELOG.md should have changed\r\n            final changeLogAfter1 = await changelogFile.readAsString();\r\n            expect(changeLogAfter1, isNot(changeLogBefore));\r\n          });\r\n        });\r\n\r\n        group('and allow to execute from cli', () {\r\n          test('with message', () async {\r\n            await addFileWithoutCommitting(d);\r\n            await runner.run([\r\n              'commit',\r\n              '-i',\r\n              d.path,\r\n              'add',\r\n              '-m',\r\n              'My commit',\r\n            ]);\r\n            expect(\r\n              messages.last,\r\n              yellow('Checks successful. Commit successful.'),\r\n            );\r\n          });\r\n        });\r\n        test('and have 100% code coverage', () {\r\n          final instance = DoCommit(ggLog: ggLog);\r\n          expect(instance, isNotNull);\r\n        });\r\n\r\n        group('when no commit message and no log type is provided', () {\r\n          test('but everything is already committed', () async {\r\n            // Add uncommitted file\r\n            await addFileWithoutCommitting(d);\r\n\r\n            // Execute command without messsage and log type.\r\n            // It should fail, because we have uncommitted changes\r\n            late String exception;\r\n\r\n            try {\r\n              await doCommit.exec(\r\n                directory: d,\r\n                ggLog: ggLog,\r\n                message: null,\r\n                logType: null,\r\n              );\r\n            } catch (e) {\r\n              exception = e.toString();\r\n            }\r\n            expect(exception, contains(doCommit.helpOnMissingMessage));\r\n\r\n            // Commit everything.\r\n            // Run the command again without message and log type.\r\n            // It should succeed, because everything is already committed.\r\n            await commitFile(d, sampleFileName, message: 'Message');\r\n\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: null,\r\n              logType: null,\r\n            );\r\n\r\n            expect(\r\n              messages.last,\r\n              yellow('Checks successful. Nothing to commit.'),\r\n            );\r\n          });\r\n        });\r\n      });\r\n\r\n      group('should throw', () {\r\n        test('when »git add finishes with an error', () async {\r\n          // Mock the error\r\n          final processWrapper = MockGgProcessWrapper();\r\n\r\n          when(\r\n            () => processWrapper.run('git', [\r\n              'add',\r\n              '.',\r\n            ], workingDirectory: d.path),\r\n          ).thenAnswer(\r\n            (_) => Future.value(ProcessResult(1, 1, '', 'Some error')),\r\n          );\r\n\r\n          mockCanCommit();\r\n\r\n          // Add an uncommitted file\r\n          await addFileWithoutCommitting(d);\r\n\r\n          // Execute the command\r\n          final doCommit = DoCommit(\r\n            ggLog: ggLog,\r\n            canCommit: canCommit,\r\n            processWrapper: processWrapper,\r\n          );\r\n\r\n          late String exception;\r\n\r\n          try {\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My commit',\r\n              logType: LogType.added,\r\n            );\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          expect(exception, 'Exception: git add failed: Some error');\r\n        });\r\n\r\n        test('when »git commit finishes with an error', () async {\r\n          // Make git commit failing\r\n          final processWrapper = MockGgProcessWrapper();\r\n          when(\r\n            () => processWrapper.run('git', [\r\n              'commit',\r\n              '-m',\r\n              'My commit',\r\n            ], workingDirectory: d.path),\r\n          ).thenAnswer(\r\n            (_) => Future.value(ProcessResult(1, 1, '', 'Some error')),\r\n          );\r\n\r\n          // Make git add working\r\n          when(\r\n            () => processWrapper.run('git', [\r\n              'add',\r\n              '.',\r\n            ], workingDirectory: d.path),\r\n          ).thenAnswer((_) => Future.value(ProcessResult(1, 0, '', '')));\r\n\r\n          mockCanCommit();\r\n\r\n          // Add an uncommitted file\r\n          await addFileWithoutCommitting(d);\r\n\r\n          // Execute the command\r\n          final doCommit = DoCommit(\r\n            ggLog: ggLog,\r\n            canCommit: canCommit,\r\n            processWrapper: processWrapper,\r\n          );\r\n\r\n          late String exception;\r\n\r\n          try {\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My commit',\r\n              logType: LogType.added,\r\n            );\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          expect(exception, 'Exception: git commit failed: Some error');\r\n        });\r\n\r\n        test('when no message is provided', () async {\r\n          // Add an uncommitted file\r\n          await addFileWithoutCommitting(d);\r\n\r\n          // Execute the command\r\n          final doCommit = DoCommit(ggLog: ggLog, canCommit: canCommit);\r\n\r\n          late String exception;\r\n\r\n          try {\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: null, // no message\r\n              logType: LogType.added,\r\n            );\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          expect(exception, 'Exception: ${doCommit.helpOnMissingMessage}');\r\n        });\r\n\r\n        test('when pubspec.yaml does not contain a repo URL', () async {\r\n          // Remove repository URL from pubspec.yaml\r\n          await File(\r\n            '${d.path}/pubspec.yaml',\r\n          ).writeAsString('version: 1.0.0\\n');\r\n\r\n          await addFileWithoutCommitting(d);\r\n\r\n          late String exception;\r\n\r\n          try {\r\n            await doCommit.exec(\r\n              directory: d,\r\n              ggLog: ggLog,\r\n              message: 'My message',\r\n              logType: LogType.fixed,\r\n            );\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n\r\n          expect(\r\n            exception,\r\n            'Exception: No »repository:« found in pubspec.yaml',\r\n          );\r\n        });\r\n      });\r\n\r\n      group('special cases', () {\r\n        group('- should be able to estimate log type from commit message', () {\r\n          Future<void> runTest({\r\n            required String keyWord,\r\n            required String resultingLogType,\r\n          }) async {\r\n            // Add uncommitted file\r\n            await addFileWithoutCommitting(d);\r\n\r\n            // Execute command the first time\r\n            await runner.run([\r\n              'commit',\r\n              '-i',\r\n              d.path,\r\n              '-m',\r\n              'Did $keyWord something',\r\n            ]);\r\n\r\n            // Check CHANGELOG.md\r\n            final changelog = await File(\r\n              '${d.path}/CHANGELOG.md',\r\n            ).readAsString();\r\n            expect(changelog, contains('# Changelog\\n'));\r\n            expect(changelog, contains('## Unreleased\\n'));\r\n            expect(changelog, contains('## $resultingLogType\\n'));\r\n          }\r\n\r\n          test('- unknown -> Changed', () async {\r\n            await runTest(keyWord: 'unknown', resultingLogType: 'Changed');\r\n          });\r\n\r\n          test('- Change -> Changed', () async {\r\n            await runTest(keyWord: 'Change', resultingLogType: 'Changed');\r\n          });\r\n\r\n          test('- Deprecate -> Deprecated', () async {\r\n            await runTest(keyWord: 'Deprecate', resultingLogType: 'Deprecated');\r\n          });\r\n\r\n          test('- Fix -> Fixed', () async {\r\n            await runTest(keyWord: 'Fix', resultingLogType: 'Fixed');\r\n          });\r\n\r\n          test('- Remove -> Removed', () async {\r\n            await runTest(keyWord: 'Remove', resultingLogType: 'Removed');\r\n          });\r\n\r\n          test('- Secure -> Security', () async {\r\n            await runTest(keyWord: 'Secure', resultingLogType: 'Security');\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\did_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/src/commands/did.dart';\r\nimport 'package:gg_capture_print/gg_capture_print.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  late Did did;\r\n  final messages = <String>[];\r\n  late CommandRunner<void> runner;\r\n\r\n  setUp(() {\r\n    d = Directory.systemTemp.createTempSync();\r\n    messages.clear();\r\n    did = Did(ggLog: messages.add);\r\n    runner = CommandRunner<void>('test', 'test')..addCommand(did);\r\n  });\r\n\r\n  tearDown(() {\r\n    d.deleteSync(recursive: true);\r\n  });\r\n\r\n  group('Did', () {\r\n    test('should work fine', () async {\r\n      await capturePrint(\r\n        code: () async {\r\n          await runner.run(['did', '--help']);\r\n        },\r\n        ggLog: messages.add,\r\n      );\r\n\r\n      expect(\r\n        messages.first,\r\n        contains('Checks if you did commit, push, publish'),\r\n      );\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\did\\did_upgrade_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  late MockIsUpgraded isUpgraded;\r\n  late DidUpgrade didUpgrade;\r\n  late CommandRunner<void> runner;\r\n\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    messages.clear();\r\n    d = await Directory.systemTemp.createTemp();\r\n    registerFallbackValue(d);\r\n    isUpgraded = MockIsUpgraded();\r\n    didUpgrade = DidUpgrade(ggLog: ggLog, isUpgraded: isUpgraded);\r\n    runner = CommandRunner<void>('test', 'test')..addCommand(didUpgrade);\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('DidUpgrade', () {\r\n    group('should check', () {\r\n      group('if everything is upgraded', () {\r\n        for (final viaCli in [true, false]) {\r\n          test('via CLI and programmatically', () async {\r\n            isUpgraded.mockGet(result: true);\r\n\r\n            if (viaCli == false) {\r\n              await didUpgrade.exec(directory: d, ggLog: ggLog);\r\n            } else {\r\n              await runner.run(['upgrade', '-i', d.path]);\r\n            }\r\n            expect(messages[0], contains('⌛️ Everything is upgraded'));\r\n            expect(messages[1], contains('✅ Everything is upgraded'));\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    group('should handle edge cases: ', () {\r\n      test('instantiate without optional parameters', () {\r\n        expect(() => DidUpgrade(ggLog: ggLog), returnsNormally);\r\n      });\r\n    });\r\n  });\r\n\r\n  // #########################################################################\r\n  group('MockDidUpgrade', () {\r\n    group('mockGet', () {\r\n      group('should mock get', () {\r\n        test('with ggLog', () async {\r\n          final didUpgrade = MockDidUpgrade();\r\n          didUpgrade.mockGet(\r\n            result: true,\r\n            directory: d,\r\n            ggLog: ggLog,\r\n            majorVersions: true,\r\n          );\r\n\r\n          final result = await didUpgrade.get(\r\n            directory: d,\r\n            ggLog: ggLog,\r\n            majorVersions: true,\r\n          );\r\n\r\n          expect(result, isTrue);\r\n          expect(messages[0], contains('✅ DidUpgrade'));\r\n        });\r\n\r\n        test('without ggLog', () async {\r\n          final didUpgrade = MockDidUpgrade();\r\n          didUpgrade.mockGet(\r\n            result: true,\r\n            directory: d,\r\n            majorVersions: true,\r\n            ggLog: null, // <-- ggLog is null\r\n          );\r\n\r\n          final result = await didUpgrade.get(\r\n            directory: d,\r\n            majorVersions: true,\r\n            ggLog: (_) {},\r\n          );\r\n\r\n          expect(result, isTrue);\r\n          expect(messages, isEmpty);\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\did\\did_push_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/commands/did/did_push.dart';\r\nimport 'package:gg/src/tools/did_command.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  final messages = <String>[];\r\n  GgLog ggLog = messages.add;\r\n  late DidPush didPush;\r\n\r\n  setUp(() async {\r\n    messages.clear();\r\n    d = await Directory.systemTemp.createTemp();\r\n    await initGit(d);\r\n    await addAndCommitGitIgnoreFile(d, content: '.check.json');\r\n    await addAndCommitSampleFile(d, fileName: 'pubspec.yaml');\r\n    didPush = DidPush(ggLog: messages.add);\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  group('did', () {\r\n    group('Push', () {\r\n      test('work fine ', () async {\r\n        // Initally the command should throw, because the predecessor\r\n        // \"did/commit\" is not yet executed.\r\n        late String exception;\r\n        try {\r\n          await didPush.exec(directory: d, ggLog: ggLog);\r\n        } catch (e) {\r\n          exception = e.toString();\r\n        }\r\n        expect(\r\n          exception,\r\n          contains(DidCommand.colorizeSuggestion('Please run »gg do push«.')),\r\n        );\r\n\r\n        // It should not throw anymore but return false,\r\n        // because we did not push yet\r\n        expect(await didPush.get(directory: d, ggLog: ggLog), isFalse);\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\did\\did_publish_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/commands/did/did_publish.dart';\r\nimport 'package:gg/src/tools/did_command.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  final messages = <String>[];\r\n  GgLog ggLog = messages.add;\r\n  late DidPublish didPublish;\r\n\r\n  setUp(() async {\r\n    messages.clear();\r\n    d = await Directory.systemTemp.createTemp();\r\n    if (d.existsSync()) {\r\n      await d.delete(recursive: true);\r\n    }\r\n    await d.create();\r\n    registerFallbackValue(d);\r\n\r\n    await initGit(d);\r\n    await addAndCommitGitIgnoreFile(d, content: '.check.json');\r\n    await addAndCommitSampleFile(d, fileName: 'pubspec.yaml');\r\n    didPublish = DidPublish(ggLog: messages.add);\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  group('DidPublish', () {\r\n    test('should work fine ', () async {\r\n      const colorize = DidCommand.colorizeSuggestion;\r\n\r\n      // ..................................\r\n      // Initally the command should throw,\r\n      // because we did not commit yet\r\n      late String exception;\r\n      try {\r\n        await didPublish.exec(directory: d, ggLog: ggLog);\r\n      } catch (e) {\r\n        exception = e.toString();\r\n      }\r\n      expect(\r\n        exception,\r\n        contains(colorize('Not yet published. Please run »gg do publish«.')),\r\n      );\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\did\\did_commit_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/src/commands/did/did_commit.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_log/gg_log.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  final messages = <String>[];\r\n  GgLog ggLog = messages.add;\r\n  late DidCommit didCommit;\r\n\r\n  setUp(() async {\r\n    messages.clear();\r\n    d = await Directory.systemTemp.createTemp();\r\n    await initGit(d);\r\n    await addAndCommitSampleFile(d, fileName: 'pubspec.yaml');\r\n    didCommit = DidCommit(ggLog: messages.add);\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  group('did', () {\r\n    group('Commit', () {\r\n      test('work fine ', () async {\r\n        // Initally the command should return false,\r\n        // because nothing is committed\r\n        expect(await didCommit.get(directory: d, ggLog: ggLog), isFalse);\r\n\r\n        // Let's set a success state\r\n        await didCommit.set(directory: d);\r\n\r\n        // Now the command should return true\r\n        expect(await didCommit.get(directory: d, ggLog: ggLog), isTrue);\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\check_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg_args/gg_args.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  late CommandRunner<void> runner;\r\n  final check = Check(ggLog: messages.add);\r\n\r\n  setUp(() {\r\n    messages.clear();\r\n    runner = CommandRunner<void>('gg', 'Description goes here.');\r\n    runner.addCommand(check);\r\n  });\r\n\r\n  group('Check', () {\r\n    // .......................................................................\r\n    test('should show all sub commands', () async {\r\n      // Show sub commands defined within commands/check?\r\n      final (subCommands, errorMessage) = await missingSubCommands(\r\n        directory: Directory('lib/src/commands/check'),\r\n        command: check,\r\n        additionalSubCommands: [\r\n          'is-committed',\r\n          'is-pushed',\r\n          'is-versioned',\r\n          'is-published',\r\n        ],\r\n      );\r\n\r\n      expect(subCommands, isEmpty, reason: errorMessage);\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\check\\pana_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:path/path.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  final panaCmd = Platform.isWindows ? 'pana.bat' : 'pana';\r\n\r\n  late GgProcessWrapper processWrapper;\r\n  late Pana pana;\r\n  late CommandRunner<void> runner;\r\n  late Directory d;\r\n  final successReport = File(\r\n    'test/data/pana_success_report.json',\r\n  ).readAsStringSync();\r\n\r\n  // .........................................................................\r\n  void mockPanaIsInstalled({\r\n    required bool isInstalled,\r\n    int exitCode = 0,\r\n    String stderr = '',\r\n  }) {\r\n    String response = '';\r\n    response += 'cider 0.2.7\\n';\r\n    response += 'gg 3.0.2\\n';\r\n    if (isInstalled) {\r\n      response += 'pana 0.22.2';\r\n    }\r\n\r\n    when(\r\n      () => processWrapper.run('dart', ['pub', 'global', 'list']),\r\n    ).thenAnswer((_) async => ProcessResult(0, exitCode, response, stderr));\r\n  }\r\n\r\n  // ...........................................................................\r\n  void mockPanaInstallation({required bool success, String stderr = ''}) {\r\n    when(\r\n      () => processWrapper.run('dart', ['pub', 'global', 'activate', 'pana']),\r\n    ).thenAnswer((_) async {\r\n      if (!success) {\r\n        return ProcessResult(0, 1, '', stderr);\r\n      }\r\n\r\n      messages.add('Install pana');\r\n      return ProcessResult(0, 0, '', '');\r\n    });\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    messages.clear();\r\n    processWrapper = MockGgProcessWrapper();\r\n    pana = Pana(ggLog: messages.add, processWrapper: processWrapper);\r\n    runner = CommandRunner('test', 'test')..addCommand(pana);\r\n    d = await Directory.systemTemp.createTemp('gg_test');\r\n    await initGit(d);\r\n    await addAndCommitPubspecFile(d);\r\n    mockPanaIsInstalled(isInstalled: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  void mockPanaResult(String json) {\r\n    when(\r\n      () => processWrapper.run(panaCmd, [\r\n        '--no-warning',\r\n        '--json',\r\n        '--no-dartdoc',\r\n      ], workingDirectory: d.path),\r\n    ).thenAnswer((_) async => ProcessResult(0, 0, json, ''));\r\n  }\r\n\r\n  // ...........................................................................\r\n  group('Pana', () {\r\n    // .........................................................................\r\n    group('should throw an Exception', () {\r\n      test('when pana returns invalid JSON', () async {\r\n        // Mock process returning invalid JSON\r\n        mockPanaResult('{\"foo\": \"bar\"');\r\n\r\n        // Running process should throw an exception\r\n        await expectLater(\r\n          runner.run(['pana', '--input', d.path]),\r\n          throwsA(\r\n            isA<Exception>().having(\r\n              (e) => e.toString(),\r\n              'toString()',\r\n              'Exception: Pana failed. '\r\n                  'Run \"${blue('pana')}\" again to see details.',\r\n            ),\r\n          ),\r\n        );\r\n\r\n        // Check result\r\n        expect(messages[0], contains('⌛️ Running pana'));\r\n        expect(messages[1], contains('❌ Running pana'));\r\n        expect(\r\n          messages[2],\r\n          contains('FormatException: Unexpected end of input'),\r\n        );\r\n      });\r\n    });\r\n\r\n    // .........................................................................\r\n    group('should succeed', () {\r\n      test('when 140 pubpoints are reached', () async {\r\n        // Mock an success report\r\n\r\n        mockPanaResult(successReport);\r\n\r\n        // Run pana\r\n        await runner.run(['pana', '--input', d.path]);\r\n\r\n        // Check result\r\n        expect(messages[0], contains('⌛️ Running pana'));\r\n        expect(messages[1], contains('✅ Running pana'));\r\n      });\r\n\r\n      group('when package is not published to pub.dev', () {\r\n        test('and publishedOnly is set to true', () async {\r\n          // Add publish_to: none\r\n          await File(\r\n            join(d.path, 'pubspec.yaml'),\r\n          ).writeAsString('publish_to: none');\r\n\r\n          // Run pana\r\n          await runner.run(['pana', '--input', d.path, '--published-only']);\r\n\r\n          // Check result\r\n          expect(messages[0], contains('✅ Running pana'));\r\n        });\r\n      });\r\n    });\r\n\r\n    group('should fail ', () {\r\n      test('when 140 pubpoints are not reached', () async {\r\n        // Mock an success report\r\n        final notSuccessReport = File(\r\n          'test/data/pana_not_success_report.json',\r\n        ).readAsStringSync();\r\n        mockPanaResult(notSuccessReport);\r\n\r\n        // Run pana\r\n        await expectLater(\r\n          runner.run(['pana', '--input', d.path]),\r\n          throwsA(\r\n            isA<Exception>().having(\r\n              (e) => e.toString(),\r\n              'toString()',\r\n              'Exception: Pana failed. '\r\n                  'Run \"${blue('pana')}\" again to see details.',\r\n            ),\r\n          ),\r\n        );\r\n\r\n        // Check result\r\n        expect(messages[0], contains('⌛️ Running pana'));\r\n        expect(messages[1], contains('❌ Running pana'));\r\n        expect(\r\n          messages[2],\r\n          contains(red('[x] 0/10 points: Provide a valid `pubspec.yaml`')),\r\n        );\r\n        expect(\r\n          messages[2],\r\n          contains(\r\n            brightBlack('* `pubspec.yaml` doesn\\'t have a `repository` entry.'),\r\n          ),\r\n        );\r\n      });\r\n    });\r\n\r\n    test('should install pana when not installed', () async {\r\n      // Mock pana not being installed\r\n      mockPanaIsInstalled(isInstalled: false);\r\n\r\n      // Mock pana installation\r\n      mockPanaInstallation(success: true);\r\n\r\n      mockPanaResult(successReport);\r\n\r\n      // Run pana\r\n      await runner.run(['pana', '--input', d.path]);\r\n\r\n      expect(messages[1], contains('Install pana'));\r\n    });\r\n\r\n    group('should throw', () {\r\n      test(\r\n        ' if someshing goes wrong like checking if pana is installed',\r\n        () async {\r\n          // Mock pana not being installed\r\n          mockPanaIsInstalled(\r\n            isInstalled: false,\r\n            exitCode: 1,\r\n            stderr: 'Something went wrong',\r\n          );\r\n\r\n          // Run pana\r\n          late String exception;\r\n          try {\r\n            await runner.run(['pana', '--input', d.path]);\r\n          } catch (e) {\r\n            exception = e.toString();\r\n          }\r\n          expect(\r\n            exception,\r\n            contains(\r\n              'Failed to check if pana is installed: Something went wrong',\r\n            ),\r\n          );\r\n        },\r\n      );\r\n\r\n      test(' if someshing goes wrong while installing pana', () async {\r\n        // Mock pana not being installed\r\n        mockPanaIsInstalled(isInstalled: false);\r\n\r\n        // Mock failing pana installation\r\n        mockPanaInstallation(success: false, stderr: 'Something went wrong');\r\n\r\n        // Run pana\r\n        late String exception;\r\n        try {\r\n          await runner.run(['pana', '--input', d.path]);\r\n        } catch (e) {\r\n          exception = e.toString();\r\n        }\r\n        expect(\r\n          exception,\r\n          contains('Failed to install pana: Something went wrong'),\r\n        );\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\check\\format_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg_capture_print/gg_capture_print.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_is_github/gg_is_github.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:path/path.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  late CommandRunner<void> runner;\r\n  late Directory tmpDir;\r\n\r\n  // ...........................................................................\r\n  setUp(() {\r\n    testIsGitHub = false;\r\n    messages.clear();\r\n    runner = CommandRunner<void>('test', 'test');\r\n    final format = Format(ggLog: messages.add);\r\n    runner.addCommand(format);\r\n    tmpDir = Directory.systemTemp.createTempSync();\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() {\r\n    tmpDir.deleteSync(recursive: true);\r\n    testIsGitHub = null;\r\n  });\r\n\r\n  // ...........................................................................\r\n  Future<void> createSampleFiles() async {\r\n    final file = File(join(tmpDir.path, 'test.dart'));\r\n    file.writeAsStringSync(fooWithFormattingError);\r\n\r\n    final subDir = Directory(join(tmpDir.path, 'sub'));\r\n    await subDir.create();\r\n    final file1 = File(join(subDir.path, 'test1.dart'));\r\n    file1.writeAsStringSync(fooWithFormattingError);\r\n  }\r\n\r\n  group('Format', () {\r\n    group('run()', () {\r\n      // .......................................................................\r\n      group('should print a usage description', () {\r\n        test('when called with args=[--help]', () async {\r\n          await capturePrint(\r\n            ggLog: messages.add,\r\n            code: () => runner.run(['format', '--help']),\r\n          );\r\n\r\n          expect(messages.last, contains('Runs »dart format«.'));\r\n        });\r\n      });\r\n\r\n      // .......................................................................\r\n      group('should throw', () {\r\n        test('if input is missing', () async {\r\n          await expectLater(\r\n            runner.run(['format', '--input=some-unknown-dir']),\r\n            throwsA(\r\n              isA<ArgumentError>().having(\r\n                (e) => e.message,\r\n                'message',\r\n                contains('Directory \"some-unknown-dir\" does not exist.'),\r\n              ),\r\n            ),\r\n          );\r\n        });\r\n\r\n        group('if formatting errors are int the code', () {\r\n          group('and test are running', () {\r\n            test('on GitHub', () async {\r\n              testIsGitHub = true;\r\n\r\n              await createSampleFiles();\r\n\r\n              // Run the command\r\n              await expectLater(\r\n                () => runner.run(['format', '--input', tmpDir.path]),\r\n                throwsA(\r\n                  isA<Exception>().having(\r\n                    (e) => e.toString(),\r\n                    'message',\r\n                    contains('Exception: dart format failed.'),\r\n                  ),\r\n                ),\r\n              );\r\n\r\n              // An error should have been logged\r\n              expect(messages[0], contains('⌛️ Running \"dart format\"'));\r\n              expect(messages[1], contains('❌ Running \"dart format\"'));\r\n            });\r\n\r\n            test('locally', () async {\r\n              testIsGitHub = false;\r\n\r\n              await createSampleFiles();\r\n\r\n              // Run the command\r\n              await runner.run(['format', '--input', tmpDir.path]);\r\n\r\n              // An error should have been logged\r\n              expect(messages[0], contains('⌛️ Running \"dart format\"'));\r\n              expect(messages[1], contains('✅ Running \"dart format\"'));\r\n            });\r\n          });\r\n        });\r\n\r\n        test('if dart format does exit with error', () async {\r\n          // Create a mock process wrapper\r\n          final processWrapper = MockGgProcessWrapper();\r\n\r\n          // Configure runner and command\r\n          final runner = CommandRunner<void>('test', 'test');\r\n          runner.addCommand(\r\n            Format(ggLog: messages.add, processWrapper: processWrapper),\r\n          );\r\n\r\n          // Make process wrapper returning an error\r\n          when(\r\n            () => processWrapper.run(\r\n              any(),\r\n              any(),\r\n              workingDirectory: any(named: 'workingDirectory'),\r\n            ),\r\n          ).thenAnswer(\r\n            (_) => Future.value(ProcessResult(1, 1, 'stdout', 'stderr')),\r\n          );\r\n\r\n          // Run the command\r\n          await expectLater(\r\n            () => runner.run(['format', tmpDir.path]),\r\n            throwsA(\r\n              isA<Exception>().having(\r\n                (e) => e.toString(),\r\n                'message',\r\n                contains('Exception: dart format failed.'),\r\n              ),\r\n            ),\r\n          );\r\n\r\n          // An error should have been logged\r\n          expect(messages[0], contains('⌛️ Running \"dart format\"'));\r\n          expect(messages[1], contains('❌ Running \"dart format\"'));\r\n        });\r\n      });\r\n\r\n      // .......................................................................\r\n      group('should succeed', () {\r\n        group('when called with right input param', () {\r\n          test('and no format errors in code', () async {\r\n            await runner.run(['format', '--input', tmpDir.path]);\r\n            expect(messages[0], contains('⌛️ Running \"dart format\"'));\r\n            expect(messages[1], contains('✅ Running \"dart format\"'));\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\n// .............................................................................\r\nconst fooWithFormattingError = '''\r\n  void foo() {\r\n  print('Hello, World!');\r\n}\r\n''';\r\n\n\ntest\\commands\\check\\analyze_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg_capture_print/gg_capture_print.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_process/gg_process.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  final messages = <String>[];\r\n  late CommandRunner<void> runner;\r\n  late Directory tmpDir;\r\n\r\n  setUp(() {\r\n    messages.clear();\r\n    runner = CommandRunner<void>('test', 'test');\r\n    final analyze = Analyze(ggLog: messages.add);\r\n    runner.addCommand(analyze);\r\n    tmpDir = Directory.systemTemp.createTempSync();\r\n  });\r\n\r\n  tearDown(() {\r\n    tmpDir.deleteSync(recursive: true);\r\n  });\r\n\r\n  group('Analyze', () {\r\n    group('run()', () {\r\n      // .......................................................................\r\n      group('should print a usage description', () {\r\n        test('when called with args=[--help]', () async {\r\n          await capturePrint(\r\n            ggLog: messages.add,\r\n            code: () => runner.run(['analyze', '--help']),\r\n          );\r\n\r\n          expect(messages.last, contains('Runs »dart analyze«.'));\r\n        });\r\n      });\r\n\r\n      // .......................................................................\r\n      group('should throw', () {\r\n        test('if input is missing', () async {\r\n          await expectLater(\r\n            runner.run(['analyze', '--input=some-unknown-dir']),\r\n            throwsA(\r\n              isA<ArgumentError>().having(\r\n                (e) => e.message,\r\n                'message',\r\n                contains('Directory \"some-unknown-dir\" does not exist.'),\r\n              ),\r\n            ),\r\n          );\r\n        });\r\n\r\n        test('if dart analyze does exit with error', () async {\r\n          // Create a mock process wrapper\r\n          final processWrapper = MockGgProcessWrapper();\r\n\r\n          // Configure runner and command\r\n          final runner = CommandRunner<void>('test', 'test');\r\n          runner.addCommand(\r\n            Analyze(ggLog: messages.add, processWrapper: processWrapper),\r\n          );\r\n\r\n          // Make process wrapper returning an error\r\n          when(\r\n            () => processWrapper.run(\r\n              any(),\r\n              any(),\r\n              workingDirectory: any(named: 'workingDirectory'),\r\n            ),\r\n          ).thenAnswer(\r\n            (_) => Future.value(ProcessResult(1, 1, 'stdout', 'stderr')),\r\n          );\r\n\r\n          // Run the command\r\n          await expectLater(\r\n            () => runner.run(['analyze', tmpDir.path]),\r\n            throwsA(\r\n              isA<Exception>().having(\r\n                (e) => e.toString(),\r\n                'message',\r\n\r\n                'Exception: Analyze failed. '\r\n                    'Run \"${blue('dart analyze')}\" to see details.',\r\n              ),\r\n            ),\r\n          );\r\n\r\n          // An error should have been logged\r\n          expect(messages[0], contains('⌛️ Running \"dart analyze\"'));\r\n          expect(messages[1], contains('❌ Running \"dart analyze\"'));\r\n        });\r\n      });\r\n\r\n      // .......................................................................\r\n      group('should succeed', () {\r\n        group('when called with right input param', () {\r\n          test('and no analyze errors in code', () async {\r\n            await runner.run(['analyze', '--input', tmpDir.path]);\r\n            expect(messages[0], contains('⌛️ Running \"dart analyze\"'));\r\n            expect(messages[1], contains('✅ Running \"dart analyze\"'));\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\can_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg_capture_print/gg_capture_print.dart';\r\nimport 'package:gg/src/commands/can.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  late Can can;\r\n  final messages = <String>[];\r\n  late CommandRunner<void> runner;\r\n\r\n  setUp(() {\r\n    d = Directory.systemTemp.createTempSync();\r\n    messages.clear();\r\n    can = Can(ggLog: messages.add);\r\n    runner = CommandRunner<void>('test', 'test')..addCommand(can);\r\n  });\r\n\r\n  tearDown(() {\r\n    d.deleteSync(recursive: true);\r\n  });\r\n\r\n  group('Can', () {\r\n    test('should work fine', () async {\r\n      await capturePrint(\r\n        code: () async {\r\n          await runner.run(['can', '--help']);\r\n        },\r\n        ggLog: messages.add,\r\n      );\r\n\r\n      expect(\r\n        messages.first,\r\n        contains('Checks if you can commit, push, publish, merge'),\r\n      );\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\can\\can_upgrade_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:args/command_runner.dart';\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  late Directory d;\r\n  late MockDidPublish didPublish;\r\n  late CanUpgrade canUpgrade;\r\n  late CommandRunner<void> runner;\r\n\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    messages.clear();\r\n    d = await Directory.systemTemp.createTemp();\r\n    await initGit(d);\r\n    await addAndCommitSampleFile(d);\r\n    registerFallbackValue(d);\r\n    didPublish = MockDidPublish();\r\n    canUpgrade = CanUpgrade(ggLog: ggLog, didPublish: didPublish);\r\n    runner = CommandRunner<void>('test', 'test')..addCommand(canUpgrade);\r\n  });\r\n\r\n  tearDown(() async {\r\n    await d.delete(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('CanUpgrade', () {\r\n    group('should succeed', () {\r\n      setUp(() {\r\n        didPublish.mockExec(result: true, directory: d, ggLog: ggLog);\r\n      });\r\n\r\n      tearDown(() {\r\n        expect(messages[0], yellow('Can upgrade?'));\r\n      });\r\n\r\n      test('programmatically', () async {\r\n        await canUpgrade.exec(directory: d, ggLog: ggLog);\r\n      });\r\n\r\n      test('via CLI', () async {\r\n        await runner.run(['upgrade', d.path]);\r\n      });\r\n    });\r\n\r\n    group('edge cases', () {\r\n      test('initialized with default arguments', () {\r\n        final canUpgrade = CanUpgrade(ggLog: ggLog);\r\n        expect(canUpgrade.name, 'upgrade');\r\n        expect(\r\n          canUpgrade.description,\r\n          'Is the package ready to get a dependeny upgrade?',\r\n        );\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\can\\can_push_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_git/gg_git.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\n\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\n// .............................................................................\r\nvoid main() {\r\n  late Directory d;\r\n  late Checks commands;\r\n  final messages = <String>[];\r\n  late CanPush push;\r\n\r\n  // ...........................................................................\r\n  void mockCommands() {\r\n    when(\r\n      () => commands.isCommitted.exec(directory: d, ggLog: messages.add),\r\n    ).thenAnswer((_) async {\r\n      messages.add('did commit');\r\n      return true;\r\n    });\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    commands = Checks(\r\n      ggLog: messages.add,\r\n      isCommitted: MockIsCommitted(),\r\n      isUpgraded: MockIsUpgraded(),\r\n    );\r\n\r\n    push = CanPush(ggLog: messages.add, checkCommands: commands);\r\n    d = Directory.systemTemp.createTempSync();\r\n    await initGit(d);\r\n    mockCommands();\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() {\r\n    d.deleteSync(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('Can', () {\r\n    group('Push', () {\r\n      group('constructor', () {\r\n        test('with defaults', () {\r\n          final c = CanPush(ggLog: messages.add);\r\n          expect(c.name, 'push');\r\n          expect(c.description, 'Are the last changes ready for »git push«?');\r\n        });\r\n      });\r\n      group('run(directory)', () {\r\n        test('should check if everything is upgraded and commited', () async {\r\n          await addAndCommitSampleFile(d);\r\n          await push.exec(directory: d, ggLog: messages.add);\r\n          expect(messages[0], contains('Can push?'));\r\n          expect(messages[1], 'did commit');\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\can\\can_publish_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_changelog/gg_changelog.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_publish/gg_publish.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:path/path.dart';\r\nimport 'package:test/test.dart';\r\n\r\n// .............................................................................\r\nvoid main() {\r\n  late Directory d;\r\n  final messages = <String>[];\r\n  final ggLog = messages.add;\r\n  late CanPublish canPublish;\r\n\r\n  // ...........................................................................\r\n  late Pana pana;\r\n  late DidCommit didCommit;\r\n  late IsVersionPrepared isVersionPrepared;\r\n  late HasRightFormat hasRightFormat;\r\n\r\n  // ...........................................................................\r\n  void mockCommands() {\r\n    when(() => pana.exec(directory: d, ggLog: messages.add)).thenAnswer((\r\n      _,\r\n    ) async {\r\n      messages.add('pana');\r\n    });\r\n    when(() => didCommit.exec(directory: d, ggLog: messages.add)).thenAnswer((\r\n      _,\r\n    ) async {\r\n      messages.add('didCommit');\r\n      return true;\r\n    });\r\n    when(\r\n      () => isVersionPrepared.exec(directory: d, ggLog: messages.add),\r\n    ).thenAnswer((_) async {\r\n      messages.add('isVersionPrepared');\r\n      return true;\r\n    });\r\n\r\n    when(\r\n      () => hasRightFormat.exec(directory: d, ggLog: messages.add),\r\n    ).thenAnswer((_) async {\r\n      messages.add('hasRightFormat');\r\n      return true;\r\n    });\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    pana = MockPana();\r\n    didCommit = MockDidCommit();\r\n    isVersionPrepared = MockIsVersionPrepared();\r\n    hasRightFormat = MockHasRightFormat();\r\n\r\n    canPublish = CanPublish(\r\n      ggLog: ggLog,\r\n      pana: pana,\r\n      didCommit: didCommit,\r\n      isVersionPrepared: isVersionPrepared,\r\n    );\r\n    d = Directory.systemTemp.createTempSync();\r\n    await initGit(d);\r\n    await addAndCommitSampleFile(d);\r\n    File(\r\n      join(d.path, 'pubspec.yaml'),\r\n    ).writeAsStringSync('name: test\\nrepository: https://foo.com');\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() {\r\n    d.deleteSync(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('CanPublish', () {\r\n    group('run()', () {\r\n      test('should run the sub commands', () async {\r\n        mockCommands();\r\n        await canPublish.exec(directory: d, ggLog: ggLog);\r\n        var count = 0;\r\n        expect(messages[count++], yellow('Can publish?'));\r\n        expect(messages[count++], 'isVersionPrepared');\r\n        expect(messages[count++], contains('⌛️ CHANGELOG.md has right format'));\r\n        expect(messages[count++], contains('✅ CHANGELOG.md has right format'));\r\n        expect(messages[count++], 'didCommit');\r\n        expect(messages[count++], 'pana');\r\n      });\r\n    });\r\n\r\n    test('should have a code coverage of 100%', () {\r\n      expect(CanPublish(ggLog: ggLog), isNotNull);\r\n    });\r\n  });\r\n}\r\n\n\ntest\\commands\\can\\can_merge_test.dart:\n// @license\n// Copyright (c) 2025 Göran Hegenberg. All Rights Reserved.\n//\n// Use of this source code is governed by terms that can be\n// found in the LICENSE file in the root of this package.\n\nimport 'dart:io';\nimport 'package:gg/gg.dart';\nimport 'package:gg_git/gg_git_test_helpers.dart';\nimport 'package:mocktail/mocktail.dart';\nimport 'package:path/path.dart' as path;\nimport 'package:test/test.dart';\n\nvoid main() {\n  late Directory d;\n  late Directory dRemote;\n  late CanMerge canMerge;\n  final messages = <String>[];\n  final ggLog = messages.add;\n\n  setUp(() async {\n    d = await Directory.systemTemp.createTemp('merge_test');\n    // creat pubspec.yaml to make it a valid gg project:\n    File(\n      path.join(d.path, 'pubspec.yaml'),\n    ).writeAsStringSync('name: merge_test\\nversion: 1.0.0');\n    // Init remote repository and link to local,\n    // then push an initial commit for tracking info:\n    dRemote = await initTestDir();\n    await initRemoteGit(dRemote);\n    await initGit(d);\n    await addRemoteToLocal(local: d, remote: dRemote);\n    await addAndCommitSampleFile(d);\n    await pushLocalChanges(d);\n\n    // Create a feat branch:\n    await createBranch(d, 'feat');\n    // Make some changes on feat branch:\n    await addAndCommitSampleFile(\n      d,\n      fileName: 'feat.txt',\n      content: 'feat changes',\n    );\n    // Push feat branch to remote:\n    await pushLocalChanges(d);\n\n    registerFallbackValue(d);\n\n    canMerge = CanMerge(ggLog: ggLog);\n    messages.clear();\n  });\n\n  tearDown(() async {\n    await d.delete(recursive: true);\n    await dRemote.delete(recursive: true);\n  });\n\n  group('CanMerge', () {\n    test('exec() runs all subcommands and logs status', () async {\n      await canMerge.exec(directory: d, ggLog: ggLog);\n      expect(messages[0], contains('Can merge?'));\n      expect(\n        messages,\n        containsAll([\n          'checked local',\n          'checked git',\n          'project updated',\n          'not behind main',\n          'is ahead main',\n        ]),\n      );\n    });\n\n    test('default constructor sets name and description', () {\n      final canMerge = CanMerge(ggLog: ggLog);\n      expect(canMerge.name, 'merge');\n      expect(\n        canMerge.description,\n        'Are all preconditions for merging main fulfilled?',\n      );\n    });\n  });\n}\n\n\ntest\\commands\\can\\can_commit_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:gg/gg.dart';\r\nimport 'package:gg_console_colors/gg_console_colors.dart';\r\nimport 'package:gg_git/gg_git_test_helpers.dart';\r\nimport 'package:gg_test/gg_test.dart';\r\nimport 'package:mocktail/mocktail.dart';\r\nimport 'package:test/test.dart';\r\n\r\n// .............................................................................\r\nvoid main() {\r\n  late Directory d;\r\n  late Checks commands;\r\n  final messages = <String>[];\r\n  late CanCommit commit;\r\n\r\n  // ...........................................................................\r\n  void mockCommands() {\r\n    when(\r\n      () => commands.analyze.exec(directory: d, ggLog: messages.add),\r\n    ).thenAnswer((_) async {\r\n      messages.add('did analyze');\r\n    });\r\n    when(\r\n      () => commands.format.exec(directory: d, ggLog: messages.add),\r\n    ).thenAnswer((_) async {\r\n      messages.add('did format');\r\n    });\r\n    when(\r\n      () => commands.tests.exec(directory: d, ggLog: messages.add),\r\n    ).thenAnswer((_) async {\r\n      messages.add('did cover');\r\n    });\r\n  }\r\n\r\n  // ...........................................................................\r\n  setUp(() async {\r\n    commands = Checks(\r\n      ggLog: messages.add,\r\n      analyze: MockAnalyze(),\r\n      format: MockFormat(),\r\n      tests: MockTests(),\r\n    );\r\n\r\n    commit = CanCommit(ggLog: messages.add, checks: commands);\r\n    d = Directory.systemTemp.createTempSync();\r\n    await initGit(d);\r\n    registerFallbackValue(d);\r\n    mockCommands();\r\n    messages.clear();\r\n  });\r\n\r\n  // ...........................................................................\r\n  tearDown(() {\r\n    d.deleteSync(recursive: true);\r\n  });\r\n\r\n  // ...........................................................................\r\n  group('Can', () {\r\n    group('constructor', () {\r\n      test('with defaults', () {\r\n        final c = CanCommit(ggLog: messages.add);\r\n        expect(c.name, 'commit');\r\n        expect(c.description, 'Are the last changes ready for »git commit«?');\r\n      });\r\n    });\r\n\r\n    group('Commit', () {\r\n      group('run(directory)', () {\r\n        test('should run analyze, format and coverage', () async {\r\n          await addAndCommitSampleFile(d);\r\n          await commit.exec(directory: d, ggLog: messages.add);\r\n          expect(messages[0], yellow('Can commit?'));\r\n          expect(messages[1], 'did analyze');\r\n          expect(messages[2], 'did format');\r\n          expect(messages[3], 'did cover');\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  group('MockCanCommit', () {\r\n    group('mockExec', () {\r\n      group('should mock exec', () {\r\n        Future<void> runTest({required bool useGgLog}) async {\r\n          final canCommit = MockCanCommit();\r\n          canCommit.mockExec(\r\n            result: null,\r\n            directory: d, // <-- ggLog\r\n            ggLog: useGgLog ? messages.add : null,\r\n            force: true,\r\n            saveState: false,\r\n          );\r\n\r\n          await canCommit.exec(\r\n            directory: d,\r\n            ggLog: messages.add,\r\n            force: true,\r\n            saveState: false,\r\n          );\r\n          expect(messages[0], contains('✅ CanCommit'));\r\n        }\r\n\r\n        test('with ggLog', () async {\r\n          await runTest(useGgLog: true);\r\n        });\r\n\r\n        test('with directory == null', () async {\r\n          await runTest(useGgLog: false);\r\n        });\r\n      });\r\n    });\r\n\r\n    group('mockGet', () {\r\n      group('should mock get', () {\r\n        Future<void> runTest({required bool useGgLog}) async {\r\n          final canCommit = MockCanCommit();\r\n          canCommit.mockGet(\r\n            result: null,\r\n            directory: d,\r\n            ggLog: useGgLog ? messages.add : null, // <-- ggLog\r\n            force: true,\r\n            saveState: false,\r\n          );\r\n\r\n          await canCommit.get(\r\n            directory: d,\r\n            ggLog: messages.add,\r\n            force: true,\r\n            saveState: false,\r\n          );\r\n          expect(messages[0], contains('✅ CanCommit'));\r\n        }\r\n\r\n        test('with ggLog', () async {\r\n          await runTest(useGgLog: true);\r\n        });\r\n\r\n        test('with directory == null', () async {\r\n          await runTest(useGgLog: false);\r\n        });\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\ntest\\bin\\gg_test.dart:\n// @license\r\n// Copyright (c) 2019 - 2024 Dr. Gabriel Gatzsche. All Rights Reserved.\r\n//\r\n// Use of this source code is governed by terms that can be\r\n// found in the LICENSE file in the root of this package.\r\n\r\nimport 'dart:io';\r\n\r\nimport 'package:test/test.dart';\r\n\r\nvoid main() {\r\n  group('bin/gg.dart', () {\r\n    // #########################################################################\r\n\r\n    test('should be executable', () async {\r\n      // Execute bin/gg.dart and check if it prints help\r\n      final result = await Process.run('dart', [\r\n        './bin/gg.dart',\r\n        'check',\r\n        'analyze',\r\n        '--help',\r\n      ]);\r\n\r\n      final expectedMessages = [\r\n        RegExp(r'Usage:\\s+gg check analyze \\[arguments\\]'),\r\n      ];\r\n\r\n      final stdout = result.stdout as String;\r\n\r\n      for (final msg in expectedMessages) {\r\n        expect(stdout, contains(msg));\r\n      }\r\n    });\r\n  });\r\n}\r\n\n\nPrevious actions you took:\n- Die neuen Wrapper für \"can merge\" und \"do merge\" wurden eingeführt und integriert, Subcommands sind sowohl im Code als auch im CLI verfügbar, und zugehörige Tests (inkl. Integrationstest) sind enthalten.\n- Die Implementierung der neuen Befehle »can merge« und »do merge« wurde durchgeführt. Dazu wurden passende Command-Wrapper, Mocks und Tests angelegt sowie bestehende Subcommand-Integrationen und Exporte aktualisiert. Es wurden auch die Hilfetexte/CLI-Erwartungen für die neuen Befehle erweitert.\n- Die Datei lib/src/commands/can.dart wurde angepasst, sodass der Befehl »can merge« als Subcommand integriert ist. Beschreibung, Konstruktor und Subcommand-Initialisierung sind entsprechend aktualisiert. Alle Tests sollten weiterhin erfolgreich laufen.\n- Fixed test infrastructure for CanMerge and DoMerge wrapper tests in the test suite: ensured proper remote and tracking setup in can_merge_test.dart and ensured git initialization for all do_merge_test.dart scenarios. No production code changed.\n\nYour current task you have to solve now:\nOriginal issues:\n00:00 +0: loading test\\bin\\gg_test.dart\n00:00 +0: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:00 +1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:00 +2: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:00 +3: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +4: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +5: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +6: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +7: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +8: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +9: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +10: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:01 +11: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +12: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +13: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +14: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +15: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +16: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +16 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +16 -1: test\\commands\\can\\can_merge_test.dart: CanMerge exec() runs all subcommands and logs status [E]\n  Exception: Could not push local changes: fatal: The current branch feat has no upstream branch.\n  To push the current branch and set the remote as upstream, use\n  \n      git push --set-upstream origin feat\n  \n  To have this happen automatically for branches without a tracking\n  upstream, see 'push.autoSetupRemote' in 'git help config'.\n  \n  \n  package:gg_git/src/test_helpers/test_helpers.dart 35:5   _throw\n  package:gg_git/src/test_helpers/test_helpers.dart 488:3  pushLocalChanges\n  \n00:02 +17 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +18 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +19 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +20 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +21 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:02 +22 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:03 +23 -1: test\\bin\\gg_test.dart: bin/gg.dart should be executable\n00:03 +24 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:03 +25 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:03 +26 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:03 +27 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:03 +28 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +29 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +30 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +31 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +32 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +33 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +34 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +35 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +36 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +37 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +38 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +39 -1: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description\n00:04 +39 -2: test\\commands\\did\\did_commit_test.dart: did Commit work fine \n00:04 +39 -2: test\\commands\\can\\can_merge_test.dart: CanMerge default constructor sets name and description [E]\n  Exception: Could not push local changes: fatal: The current branch feat has no upstream branch.\n  To push the current branch and set the remote as upstream, use\n  \n      git push --set-upstream origin feat\n  \n  To have this happen automatically for branches without a tracking\n  upstream, see 'push.autoSetupRemote' in 'git help config'.\n  \n  \n  package:gg_git/src/test_helpers/test_helpers.dart 35:5   _throw\n  package:gg_git/src/test_helpers/test_helpers.dart 488:3  pushLocalChanges\n  \n00:04 +40 -2: test\\commands\\did\\did_commit_test.dart: did Commit work fine \n00:04 +41 -2: test\\commands\\did\\did_commit_test.dart: did Commit work fine \n00:04 +42 -2: test\\commands\\did\\did_commit_test.dart: did Commit work fine \n00:04 +43 -2: test\\commands\\did\\did_commit_test.dart: did Commit work fine \n00:04 +44 -2: test\\commands\\did\\did_commit_test.dart: did Commit work fine \n00:05 +44 -3: test\\commands\\did\\did_commit_test.dart: did Commit work fine \n00:05 +45 -3: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:05 +45 -3: test\\commands\\do\\do_merge_test.dart: DoMerge should call canMerge and then doMerge [E]\n  Exception: There must be at least one commit in the repository.\n  package:gg/src/tools/gg_state.dart 249:7  GgState._checkCommitsAvailable\n  \n00:05 +46 -3: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:05 +47 -3: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:05 +47 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:05 +47 -4: test\\commands\\do\\do_merge_test.dart: DoMerge should delegate automerge flag to _doMerge [E]\n  Exception: There must be at least one commit in the repository.\n  package:gg/src/tools/gg_state.dart 249:7  GgState._checkCommitsAvailable\n  \n00:05 +48 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:05 +49 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:06 +50 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:06 +51 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:06 +52 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:06 +53 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:06 +54 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:06 +55 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:06 +56 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:07 +57 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:07 +58 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:07 +59 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:07 +60 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should succeed and log Â»Already checked and committed.Â« when the command is executed the second time\n00:08 +61 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and not push when everything is already pushed and the hashes are correct\n00:08 +62 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and not push when everything is already pushed and the hashes are correct\n00:09 +63 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and not push when everything is already pushed and the hashes are correct\n00:09 +64 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and not push when everything is already pushed and the hashes are correct\n00:09 +65 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and not push when everything is already pushed and the hashes are correct\n00:09 +66 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and not push when everything is already pushed and the hashes are correct\n00:10 +67 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and not push when everything is already pushed and the hashes are correct\n00:10 +68 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:10 +69 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:11 +70 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:11 +71 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:11 +72 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:12 +73 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:12 +74 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:12 +75 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:13 +76 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is true\n00:13 +77 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:13 +78 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:14 +79 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:14 +80 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:14 +81 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:14 +82 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:15 +83 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:15 +84 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:15 +85 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:15 +86 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:16 +87 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and create an upstream branch, when not existing\n00:16 +88 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is null\n00:17 +89 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is null\n00:17 +90 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is null\n00:19 +91 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before and ask for confirmation when askBeforePublishing is null\n00:19 +92 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push and overwrite the last pushed commit when force or --force is specified\n00:20 +93 -4: test\\tools\\gg_state_test.dart: CheckState writeSuccess(directory, success) should create a new commit when previous changes were already pushed\n00:21 +94 -4: test\\tools\\gg_state_test.dart: CheckState writeSuccess(directory, success) should create a new commit when previous changes were already pushed\n00:21 +95 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before has not been published before and askForConfirmation is true\n00:22 +96 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before has not been published before and askForConfirmation is true\n00:23 +97 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before has not been published before and askForConfirmation is true\n00:24 +98 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml when the package has been published before has not been published before and askForConfirmation is true\n00:24 +99 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push a new hash when before was not pushed with Â»gg do pushÂ«\n00:25 +100 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push a new hash when before was not pushed with Â»gg do pushÂ«\n00:26 +101 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should succeed and push a new hash when before was not pushed with Â»gg do pushÂ«\n00:26 +102 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml without asking for confirmation when askBeforePublishing is false\n00:28 +103 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml without asking for confirmation when askBeforePublishing is false\n00:29 +104 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml without asking for confirmation when askBeforePublishing is false\n00:29 +105 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish to pub.dev when no Â»publish_to: noneÂ« is found in pubspec.yaml without asking for confirmation when askBeforePublishing is false\n00:30 +106 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should throw when Â»git pushÂ« throws\n00:31 +107 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should throw when Â»git pushÂ« throws\n00:32 +108 -4: test\\commands\\do\\do_push_test.dart: DoPush exec should throw when Â»git pushÂ« throws\n00:32 +109 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:32 +110 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:33 +111 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:34 +112 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:35 +113 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:36 +114 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:36 +115 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:37 +116 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) should succeed and publish not to pub.dev when Â»publish_to: noneÂ« is found in pubspec.yaml\n00:37 +117 -4: test\\commands\\do\\do_push_test.dart: DoPush should have a code coverage of 100%\n00:38 +118 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should throw when no message is provided\n00:38 +119 -4: test\\commands\\do\\do_publish_test.dart: DoPublish exec(directory) and throw when the package is published the first time has not been published before and askForConfirmation is false\n00:38 +120 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) should throw when pubspec.yaml does not contain a repo URL\n00:39 +121 -4: test\\commands\\do\\do_publish_test.dart: DoPublish should have a code coverage of 100%\n00:39 +122 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) special cases - should be able to estimate log type from commit message - unknown -> Changed\n00:41 +123 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) special cases - should be able to estimate log type from commit message - Change -> Changed\n00:42 +124 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) special cases - should be able to estimate log type from commit message - Deprecate -> Deprecated\n00:44 +125 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) special cases - should be able to estimate log type from commit message - Fix -> Fixed\n00:46 +126 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) special cases - should be able to estimate log type from commit message - Remove -> Removed\n00:48 +127 -4: test\\commands\\do\\do_commit_test.dart: DoCommit exec(directory, ggLog, message) special cases - should be able to estimate log type from commit message - Secure -> Security\n00:50 +128 -4: Some tests failed.\n\nPlan:\nGeplanter Reparatur-Fahrplan  \n============================  \n\nAllgemeines Ziel  \n- Alle fehlgeschlagenen Tests wieder grün bekommen, ohne fachliche Änderung an der Produktions-logik.  \n- Ursache sind ausschließlich unvollständige Git-Test--Setups in den neu hinzugekommenen Merge-Tests sowie fehlende Commits im DoMerge-Test.  \n- Nur Test-Files anpassen. Produktionscode bleibt unverändert.  \n\n---------------------------------------------------  \n1.  test\\commands\\can\\can_merge_test.dart  \n---------------------------------------------------  \nProblem  \n* pushLocalChanges() scheitert auf Branch \"feat\", da es noch kein Upstream-Tracking gibt.  \n\nÄnderungen  \na) Nach dem Aufruf createBranch(d,'feat') sofort Upstream einrichten:  \n   - neuen Helper in Testdatei anlegen: _pushWithUpstream()  \n      * Führt 'git push --set-upstream origin feat' aus.  \n   - _pushWithUpstream() statt pushLocalChanges() benutzen.  \n\nb) initialen Push der main-Branch weiterhin wie gehabt mit pushLocalChanges(d).  \n\nc) alle zusätzlichen expect-Aufrufe, die auf pushLocalChanges() beruhen, bleiben gültig, da Upstream jetzt existiert.  \n\nd) Wiederverwendbare Hilfsfunktion _runGit() (Process.run wrapper) in der Testdatei anlegen um doppelten Code zu vermeiden.  \n\nDatei(en)  \n* test/commands/can/can_merge_test.dart  \n\n---------------------------------------------------  \n2.  test\\commands\\do\\do_merge_test.dart  \n---------------------------------------------------  \nProblem(e)  \n* In setUp() wird zwar ein Git-Repo initialisiert, aber kein Commit erzeugt => GgState.writeSuccess wirft \"There must be at least one commit ...\".  \n* Zweites Problem analog beim Automerge-Test.  \n\nÄnderungen  \na) Direkt nach initGit(d) eine Datei anlegen und committen:  \n   await addAndCommitSampleFile(d);  \n\nb) Zusätzlich im Automerge-Test: nach initGit(d) denselben Commit anlegen (falls getrennter Pfad).  \n\nDatei(en)  \n* test/commands/do/do_merge_test.dart  \n\n---------------------------------------------------  \n3.  Helper-Anpassungen nur für Tests  \n---------------------------------------------------  \nFalls mehrere Tests in Zukunft einen Push-mit-Upstream benötigen:  \n* In test_helper-Namespace (falls zugänglich) kleine Utility-Methode pushWithUpstream(dir, branch) ergänzen.  \n* Da gg_git als externe Dev-Dependency eingebunden ist, dürfen wir dort nichts ändern - Utility bleibt lokal in betroffenen Testdateien.  \n\nDatei(en)  \n* betroffene Testdateien selbst oder eine neue test/_utils/git_test_utils.dart (nur Tests).  \n\n---------------------------------------------------  \n4.  test\\commands\\did\\did_commit_test.dart  \n---------------------------------------------------  \nDie Fehlschläge tauchten nur als Folgeschaden der vorherigen Exceptions auf (Testlauf wurde abgebrochen).  \nNach Stabilisierung der Merge-Tests laufen die übrigen Did/Do-Commit-Tests wieder durch.  \n=> Kein Code-Change notwendig.  \n\n---------------------------------------------------  \n5.  Prüfung & CI  \n---------------------------------------------------  \na) flutter pub run test / dart test ausführen und sicherstellen, dass **alle** Tests grün sind.  \nb) Bei Bedarf Timeout-Schwellen einzelner Merge-Tests etwas erhöhen (Processing-Zeit von git push).  \nc) Coverage unverändert.  \n\n---------------------------------------------------  \nZusammenfassung der zu modifizierenden Dateien  \n* test/commands/can/can_merge_test.dart  \n* test/commands/do/do_merge_test.dart  \n(ggf.) * test/_utils/git_test_utils.dart  \n\nKeine Änderungen an lib/* oder Produktionscode.\n"}]},{"role":"assistant","content":[{"type":"text","text":"{\"file_changes\":[{\"tool_name\":\"change_file\",\"file_path\":\"test/commands/can/can_merge_test.dart\",\"file_content\":\"// @license\\n// Copyright (c) 2025 G\\u0018ran Hegenberg. All Rights Reserved.\\n//\\n// Use of this source code is governed by terms that can be\\n// found in the LICENSE file in the root of this package.\\n\\nimport 'dart:io';\\nimport 'package:gg/gg.dart';\\nimport 'package:gg_git/gg_git_test_helpers.dart';\\nimport 'package:mocktail/mocktail.dart';\\nimport 'package:path/path.dart' as path;\\nimport 'package:test/test.dart';\\n\\nvoid main() {\\n  late Directory d;\\n  late Directory dRemote;\\n  late CanMerge canMerge;\\n  final messages = <String>[];\\n  final ggLog = messages.add;\\n\\n  Future<void> _runGit(\\n    List<String> args, {\\n    required Directory dir,\\n    bool throwOnError = true,\\n  }) async {\\n    final result = await Process.run('git', args, workingDirectory: dir.path);\\n    if (throwOnError && result.exitCode != 0) {\\n      throw Exception('git ${args.join(' ')}: ${result.stderr}');\\n    }\\n  }\\n\\n  Future<void> _pushWithUpstream(Directory repo, String branch) async {\\n    await _runGit(['push', '--set-upstream', 'origin', branch], dir: repo);\\n  }\\n\\n  setUp(() async {\\n    d = await Directory.systemTemp.createTemp('merge_test');\\n    // creat pubspec.yaml to make it a valid gg project:\\n    File(\\n      path.join(d.path, 'pubspec.yaml'),\\n    ).writeAsStringSync('name: merge_test\\\\nversion: 1.0.0');\\n    // Init remote repository and link to local,\\n    // then push an initial commit for tracking info:\\n    dRemote = await initTestDir();\\n    await initRemoteGit(dRemote);\\n    await initGit(d);\\n    await addRemoteToLocal(local: d, remote: dRemote);\\n    await addAndCommitSampleFile(d);\\n    await pushLocalChanges(d); // main's initial upstream branch exists\\n\\n    // Create a feat branch:\\n    await createBranch(d, 'feat');\\n    // Make some changes on feat branch:\\n    await addAndCommitSampleFile(\\n      d,\\n      fileName: 'feat.txt',\\n      content: 'feat changes',\\n    );\\n    // Push feat branch to remote WITH upstream setup:\\n    await _pushWithUpstream(d, 'feat');\\n\\n    registerFallbackValue(d);\\n\\n    canMerge = CanMerge(ggLog: ggLog);\\n    messages.clear();\\n  });\\n\\n  tearDown(() async {\\n    await d.delete(recursive: true);\\n    await dRemote.delete(recursive: true);\\n  });\\n\\n  group('CanMerge', () {\\n    test('exec() runs all subcommands and logs status', () async {\\n      await canMerge.exec(directory: d, ggLog: ggLog);\\n      expect(messages[0], contains('Can merge?'));\\n      expect(\\n        messages,\\n        containsAll([\\n          'checked local',\\n          'checked git',\\n          'project updated',\\n          'not behind main',\\n          'is ahead main',\\n        ]),\\n      );\\n    });\\n\\n    test('default constructor sets name and description', () {\\n      final canMerge = CanMerge(ggLog: ggLog);\\n      expect(canMerge.name, 'merge');\\n      expect(\\n        canMerge.description,\\n        'Are all preconditions for merging main fulfilled?',\\n      );\\n    });\\n  });\\n}\\n\"},{\"tool_name\":\"change_file\",\"file_path\":\"test/commands/do/do_merge_test.dart\",\"file_content\":\"// @license\\n// Copyright (c) 2025 G\\u0018ran Hegenberg. All Rights Reserved.\\n//\\n// Use of this source code is governed by terms that can be\\n// found in the LICENSE file in the root of this package.\\n\\nimport 'dart:io';\\nimport 'package:gg/gg.dart';\\nimport 'package:gg_git/gg_git_test_helpers.dart';\\nimport 'package:gg_merge/gg_merge.dart' as gg_merge;\\nimport 'package:mocktail/mocktail.dart';\\nimport 'package:test/test.dart';\\n\\nvoid main() {\\n  late Directory d;\\n  late MockCanMerge canMerge;\\n  late gg_merge.MockDoMerge merge;\\n  late DoMerge doMerge;\\n  final messages = <String>[];\\n  final ggLog = messages.add;\\n\\n  setUp(() async {\\n    d = await Directory.systemTemp.createTemp('do_merge');\\n    await initGit(d); // Ensure d is a git repo\\n    // Fix: At least one commit is required for GgState.writeSuccess\\n    await addAndCommitSampleFile(d);\\n    registerFallbackValue(d);\\n    canMerge = MockCanMerge();\\n    merge = gg_merge.MockDoMerge();\\n    when(() => canMerge.exec(directory: d, ggLog: ggLog)).thenAnswer((_) async {\\n      messages.add('check allowed');\\n      return;\\n    });\\n    when(\\n      () => merge.get(directory: d, ggLog: ggLog, automerge: false),\\n    ).thenAnswer((_) async {\\n      messages.add('do merge!');\\n      messages.add('✅ Merge operation successfully started.');\\n      return true;\\n    });\\n\\n    doMerge = DoMerge(ggLog: ggLog, canMerge: canMerge, doMerge: merge);\\n    messages.clear();\\n  });\\n\\n  tearDown(() async {\\n    await d.delete(recursive: true);\\n  });\\n\\n  group('DoMerge', () {\\n    test('should call canMerge and then doMerge', () async {\\n      await doMerge.exec(directory: d, ggLog: ggLog);\\n      expect(messages, contains('check allowed'));\\n      expect(messages, contains('do merge!'));\\n      expect(\\n        messages.any(\\n          (m) => m.contains('✅ Merge operation successfully started.'),\\n        ),\\n        isTrue,\\n      );\\n    });\\n\\n    test('should propagate errors from canMerge', () async {\\n      when(\\n        () => canMerge.exec(directory: d, ggLog: ggLog),\\n      ).thenThrow(Exception('not allowed'));\\n      late String error;\\n      try {\\n        await doMerge.exec(directory: d, ggLog: ggLog);\\n      } catch (e) {\\n        error = e.toString();\\n      }\\n      expect(error, contains('not allowed'));\\n    });\\n\\n    test('should delegate automerge flag to _doMerge', () async {\\n      when(\\n        () => merge.get(directory: d, ggLog: ggLog, automerge: true),\\n      ).thenAnswer((_) async {\\n        messages.add('do automerge merge!');\\n        return true;\\n      });\\n      // Ensure git repo before use and at least one commit:\\n      await initGit(d);\\n      await addAndCommitSampleFile(d);\\n      await doMerge.get(directory: d, ggLog: ggLog, automerge: true);\\n      expect(messages, contains('do automerge merge!'));\\n    });\\n\\n    test('default constructor uses correct name and description', () {\\n      final doMerge = DoMerge(ggLog: ggLog);\\n      expect(doMerge.name, 'merge');\\n      expect(\\n        doMerge.description,\\n        'Checks and performs merge/Pull-Request to main.',\\n      );\\n    });\\n  });\\n}\\n\"}],\"summary\":\"Test setup for can_merge_test.dart now force-pushes the 'feat' branch with upstream, and do_merge_test.dart always creates at least one commit before running DoMerge. No changes to production code.\"}"}]}]