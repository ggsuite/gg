{"file_actions":[{"tool_name":"change_file","file_path":"test/commands/can/can_merge_test.dart","file_content":"// @license\n// Copyright (c) 2025 G\u0018ran Hegenberg. All Rights Reserved.\n//\n// Use of this source code is governed by terms that can be\n// found in the LICENSE file in the root of this package.\n\nimport 'dart:io';\nimport 'package:gg/gg.dart';\nimport 'package:gg_git/gg_git_test_helpers.dart';\nimport 'package:mocktail/mocktail.dart';\nimport 'package:path/path.dart' as path;\nimport 'package:test/test.dart';\n\nvoid main() {\n  late Directory d;\n  late Directory dRemote;\n  late CanMerge canMerge;\n  final messages = <String>[];\n  final ggLog = messages.add;\n\n  Future<void> _runGit(\n    List<String> args, {\n    required Directory dir,\n    bool throwOnError = true,\n  }) async {\n    final result = await Process.run('git', args, workingDirectory: dir.path);\n    if (throwOnError && result.exitCode != 0) {\n      throw Exception('git ${args.join(' ')}: ${result.stderr}');\n    }\n  }\n\n  Future<void> _pushWithUpstream(Directory repo, String branch) async {\n    await _runGit(['push', '--set-upstream', 'origin', branch], dir: repo);\n  }\n\n  setUp(() async {\n    d = await Directory.systemTemp.createTemp('merge_test');\n    // creat pubspec.yaml to make it a valid gg project:\n    File(\n      path.join(d.path, 'pubspec.yaml'),\n    ).writeAsStringSync('name: merge_test\\nversion: 1.0.0');\n    // Init remote repository and link to local,\n    // then push an initial commit for tracking info:\n    dRemote = await initTestDir();\n    await initRemoteGit(dRemote);\n    await initGit(d);\n    await addRemoteToLocal(local: d, remote: dRemote);\n    await addAndCommitSampleFile(d);\n    await pushLocalChanges(d); // main's initial upstream branch exists\n\n    // Create a feat branch:\n    await createBranch(d, 'feat');\n    // Make some changes on feat branch:\n    await addAndCommitSampleFile(\n      d,\n      fileName: 'feat.txt',\n      content: 'feat changes',\n    );\n    // Push feat branch to remote WITH upstream setup:\n    await _pushWithUpstream(d, 'feat');\n\n    registerFallbackValue(d);\n\n    canMerge = CanMerge(ggLog: ggLog);\n    messages.clear();\n  });\n\n  tearDown(() async {\n    await d.delete(recursive: true);\n    await dRemote.delete(recursive: true);\n  });\n\n  group('CanMerge', () {\n    test('exec() runs all subcommands and logs status', () async {\n      await canMerge.exec(directory: d, ggLog: ggLog);\n      expect(messages[0], contains('Can merge?'));\n      expect(\n        messages,\n        containsAll([\n          'checked local',\n          'checked git',\n          'project updated',\n          'not behind main',\n          'is ahead main',\n        ]),\n      );\n    });\n\n    test('default constructor sets name and description', () {\n      final canMerge = CanMerge(ggLog: ggLog);\n      expect(canMerge.name, 'merge');\n      expect(\n        canMerge.description,\n        'Are all preconditions for merging main fulfilled?',\n      );\n    });\n  });\n}\n"},{"tool_name":"change_file","file_path":"test/commands/do/do_merge_test.dart","file_content":"// @license\n// Copyright (c) 2025 G\u0018ran Hegenberg. All Rights Reserved.\n//\n// Use of this source code is governed by terms that can be\n// found in the LICENSE file in the root of this package.\n\nimport 'dart:io';\nimport 'package:gg/gg.dart';\nimport 'package:gg_git/gg_git_test_helpers.dart';\nimport 'package:gg_merge/gg_merge.dart' as gg_merge;\nimport 'package:mocktail/mocktail.dart';\nimport 'package:test/test.dart';\n\nvoid main() {\n  late Directory d;\n  late MockCanMerge canMerge;\n  late gg_merge.MockDoMerge merge;\n  late DoMerge doMerge;\n  final messages = <String>[];\n  final ggLog = messages.add;\n\n  setUp(() async {\n    d = await Directory.systemTemp.createTemp('do_merge');\n    await initGit(d); // Ensure d is a git repo\n    // Fix: At least one commit is required for GgState.writeSuccess\n    await addAndCommitSampleFile(d);\n    registerFallbackValue(d);\n    canMerge = MockCanMerge();\n    merge = gg_merge.MockDoMerge();\n    when(() => canMerge.exec(directory: d, ggLog: ggLog)).thenAnswer((_) async {\n      messages.add('check allowed');\n      return;\n    });\n    when(\n      () => merge.get(directory: d, ggLog: ggLog, automerge: false),\n    ).thenAnswer((_) async {\n      messages.add('do merge!');\n      messages.add('✅ Merge operation successfully started.');\n      return true;\n    });\n\n    doMerge = DoMerge(ggLog: ggLog, canMerge: canMerge, doMerge: merge);\n    messages.clear();\n  });\n\n  tearDown(() async {\n    await d.delete(recursive: true);\n  });\n\n  group('DoMerge', () {\n    test('should call canMerge and then doMerge', () async {\n      await doMerge.exec(directory: d, ggLog: ggLog);\n      expect(messages, contains('check allowed'));\n      expect(messages, contains('do merge!'));\n      expect(\n        messages.any(\n          (m) => m.contains('✅ Merge operation successfully started.'),\n        ),\n        isTrue,\n      );\n    });\n\n    test('should propagate errors from canMerge', () async {\n      when(\n        () => canMerge.exec(directory: d, ggLog: ggLog),\n      ).thenThrow(Exception('not allowed'));\n      late String error;\n      try {\n        await doMerge.exec(directory: d, ggLog: ggLog);\n      } catch (e) {\n        error = e.toString();\n      }\n      expect(error, contains('not allowed'));\n    });\n\n    test('should delegate automerge flag to _doMerge', () async {\n      when(\n        () => merge.get(directory: d, ggLog: ggLog, automerge: true),\n      ).thenAnswer((_) async {\n        messages.add('do automerge merge!');\n        return true;\n      });\n      // Ensure git repo before use and at least one commit:\n      await initGit(d);\n      await addAndCommitSampleFile(d);\n      await doMerge.get(directory: d, ggLog: ggLog, automerge: true);\n      expect(messages, contains('do automerge merge!'));\n    });\n\n    test('default constructor uses correct name and description', () {\n      final doMerge = DoMerge(ggLog: ggLog);\n      expect(doMerge.name, 'merge');\n      expect(\n        doMerge.description,\n        'Checks and performs merge/Pull-Request to main.',\n      );\n    });\n  });\n}\n"}]}